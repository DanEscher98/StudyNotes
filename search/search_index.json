{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Paraefatio","text":"<p>Hi there</p>"},{"location":"Computing/algo-bigO_notation/","title":"Big O Notation","text":"<ul> <li>In \\(f(n) = O(g(n))\\), \\(f(n)\\) grows as most as quickly as \\(g(n)\\)</li> <li>In \\(f(n) = \\Omega(g(n))\\), \\(f(n)\\) grows at least as quickly as     \\(g(n)\\)</li> <li>If \\(f(n) = O(g(n))\\) and \\(f(n) = \\Omega(g(n))\\) then \\(f(n) =     \\Theta(g(n))\\)</li> </ul>"},{"location":"Computing/algo-fibonacci_heaps/","title":"Binary Heaps","text":""},{"location":"Computing/algo-fibonacci_heaps/#rules","title":"Rules","text":"<ol> <li>Every level is full, last one from left to right</li> <li>Heap property: No child is smaller than its parent</li> </ol>"},{"location":"Computing/algo-fibonacci_heaps/#properties","title":"Properties","text":"<ul> <li><code>GetMin</code> \\(O(1)\\): Just lookup the value of the root node, which by     rule 2 has also the minimum value.</li> <li><code>Insert</code> \\(O(\\log{n})\\): By rule 1 there\u2019s only one valid position.     If it violates rule 2, the fix is bubbling up the node until     its fixed.</li> <li><code>ExtractMin</code> \\(O(\\log{n})\\): Just removing the <code>root node</code> creates a     gap.<ol> <li>swap its value with right-most value of the last level.</li> <li>remove the <code>leaf</code>, with the former value of the <code>root node</code></li> <li>swap the <code>root node</code> value with the lowest of its <code>children    nodes</code> until rule 2 is satisfied.</li> </ol> </li> <li><code>DecreaseKey</code> \\(O(\\log{n})\\): This is useful to change priorities.<ol> <li>find the desired <code>node</code> and change its value</li> <li>fix rule 2 by bubbling the value</li> </ol> </li> </ul>"},{"location":"Computing/algo-fibonacci_heaps/#references","title":"References","text":"<ul> <li> Fibonacci Heaps - SithDev</li> </ul>"},{"location":"Computing/cc_notes.01/","title":"Bugs in code","text":"<p>compiler(code) -&gt; machine code</p> <p>(\\x.x)y -&gt; y</p> <pre><code>y=23\n</code></pre> <pre><code># file.py\ndef y():\n    return read_config(\"y\")\n\ndef multiply_by3(x: int) -&gt; int:\n    \"\"\"mutiply by 3\"\"\"\"\"\n    return y()*3\n\ndef funk():\n    return random_choose(2, \"3\")\n\ndef add_2(x: int) -&gt; int:\n    return x + 2\n\n#############\n\nfrom file import func\n\nfunk(3) # 6\nfunk()\nfunc(3) # 12\n\nadd_2(multiply_by3(3))\nadd_2(random_choose())\n</code></pre> <pre><code>f(x), state -&gt; y\n</code></pre> <ol> <li>config files</li> <li>version</li> <li>dependencies</li> </ol> <pre><code>a: deps@3.12\n    - lib@4.2\nb: pack@3.02 \n    - lib@3.9\n\ninstall y@2.9\n</code></pre>"},{"location":"Computing/cpp-basic_pointers/","title":"Pointers in C","text":""},{"location":"Computing/cpp-basic_pointers/#types-of-pointers","title":"Types of pointers","text":"<ul> <li><code>Null Pointer</code>: It\u2019s a pointer that points to nothing. They are useful     at initialization.</li> <li><code>Void Pointer</code>: It\u2019s a pointer that is not allied with any data types.     Points to some data location within the storage. It\u2019s also known     as a general purpose pointer. In C, <code>malloc</code> and <code>calloc</code>     functions return <code>void*</code>.</li> <li><code>Wild Pointer</code>: Pointers that are not initialized. It could be     initialized to a non-NULL garbage value which may not be a valid     address.</li> <li><code>Dangling Pointer</code>: A pointer that points to a memory location that     has been deleted.</li> <li><code>Struct Pointer</code>: This pointers can be utilized to refer to a struct     by its address. This helps pass structs to a function.</li> <li><code>Near Pointer</code>: It means a pointer that is utilized to bit address of     up to 16 bits within a given section of that computer memory which     is 16 bit enabled. It can only access data of the small size of     about 64kb withing a given period, which is its main disadvantage.</li> <li><code>Far Pointer</code>: Is typically 32 bit which can access memory outside     that current segment. To utilize the far pointer, the compiler     allows a segment register to save segment address, then another     register to save offset inside current segment.</li> <li><code>Huge Pointer</code>: A far pointer that is fixed and hence that part of     that sector within which they are located cannot be changed in any     way; huge pointers can be.</li> </ul> <pre><code>flowchart LR  \n    A(variable) --&gt;|&amp;| B(pointer)\n    B --&gt;|*| A</code></pre> <pre><code>// Declare a reference\nint&amp; num;\n\n// Equivalent accessing\n*(ptr + n) = val;\nptr[n] = val;\n\n// Equivalent accessing\n*(*(ch_arr + i) + j);\nch_arr[i][j];\n\n// Equivalent for structs\n(*node).next;\nnode-&gt;next;\n</code></pre>"},{"location":"Computing/cpp-basic_pointers/#references","title":"References","text":"<ul> <li> How to interpret complex <code>C/C++</code> (pointer) declarations</li> </ul>"},{"location":"Computing/hs-monadic_operators/","title":"Haskell's basic Operators","text":""},{"location":"Computing/hs-monadic_operators/#mathematics-and-lists","title":"Mathematics and Lists","text":"<ul> <li>Arithmetic: <code>+ * - / ^ ^^ **</code></li> <li>Logical: <code>&amp;&amp; || == /= &lt; &lt;= &gt;= &gt;</code></li> <li>Lists: <code>: ++ !!</code></li> </ul>"},{"location":"Computing/hs-monadic_operators/#functions-and-controlmonad","title":"Functions and Control.Monad","text":"<ul> <li><code>(.)</code> = Function composition</li> <li><code>($)</code> = Operator with right associativity and has the lowest precedence</li> <li><code>($!)</code> = The same as <code>($)</code> but also force strict evaluation</li> <li><code>(&gt;&gt;)</code> = Operator <code>then</code>, chains two monadic expressions</li> <li><code>(&gt;&gt;=)</code> = Operator <code>bind</code>, makes available the result of the previous     computation to the next expression</li> <li><code>(=&lt;&lt;)</code> = The same as operator <code>bind</code>, but with right associativity</li> <li><code>(&lt;$&gt;)</code> = Functor; this operator wraps the value. The infix of <code>fmap</code></li> <li><code>(&lt;*&gt;)</code> = Applicative; this also wraps the function</li> </ul>"},{"location":"Computing/hs-monadic_operators/#in-controlmonad","title":"In Control.Monad","text":"<ul> <li><code>(&lt;=&lt;)</code> = Allows do compositions of monadic computations</li> <li><code>(&gt;=&gt;)</code> = The same as <code>(&lt;=&lt;)</code> but with left associativity</li> </ul>"},{"location":"Computing/hs-monadic_operators/#in-datafunction","title":"In Data.Function","text":"<ul> <li><code>(&lt;$)</code> = </li> <li><code>($&gt;)</code> = </li> </ul>"},{"location":"Computing/hs-syntactic_sugar/","title":"Syntactic Sugar in Haskell","text":""},{"location":"Computing/hs-syntactic_sugar/#miscellaneous","title":"Miscellaneous","text":"Syntactic Evaluation <code>(+x)</code> <code>flip (+) x</code>"},{"location":"Computing/hs-syntactic_sugar/#lists","title":"Lists","text":"Syntactic Evaluation <code>[a]</code> <code>Lista a</code> <code>[0..2]</code> <code>[0,1,2]</code> <code>[1,2,3]</code> <code>1:2:3:[]</code> <code>[f e | e &lt;- xs]</code> <code>map f xs</code>"},{"location":"Computing/hs-syntactic_sugar/#guards","title":"Guards","text":"<p>The expression</p> <pre><code>funk x\n    | even x    = 1\n    | otherwise = 0\n</code></pre> <p>is evaluated as:</p> <pre><code>funk x = \n    if even x\n        then 1\n        else 0\n</code></pre>"},{"location":"Computing/hs-syntactic_sugar/#do-notation","title":"Do notation","text":"<pre><code>main = do\n    s &lt;- getStr\n    putStr s\n    putStr \"Hi\"\n</code></pre> <p>is evaluated as:</p> <pre><code>main = getStr &gt;&gt;=\n    (\\s -&gt; putStr s &gt;&gt; \n    (putStr \"Hi\"))\n</code></pre>"},{"location":"Computing/hs-thoughts_monads/","title":"Thoughts about Monads","text":""},{"location":"Computing/hs-thoughts_monads/#applications-of-monads","title":"Applications of Monads","text":"<ul> <li>For Haskell so loved the <code>world -&gt; (a, world)</code> that it gave us the     <code>IO Monad</code>, that whosoever composes with it should not be impure,     but free of side effects.</li> <li>They have three properties that make them useful:<ol> <li>Modularity: They allow computations to be composed from simpler    computations and separate the combination strategy from the    actual computations being performed.</li> <li>Flexibility: They allow functional programs to be much more    adaptable than equivalent programs written without monads. This    is because the monad distills the computational strategy into a    single place instead of requiring it be distributed throughout    the entire program.</li> <li>Isolation: They can be used to create imperative-style    computational structures which remain safely isolated from the    main body of the functional program. This is useful for    incorporating side-effects which remain safely isolated from    the main body of the functional program. This is useful for    incorporating side-effects and state into a pure functional    language.</li> </ol> </li> <li>Mathematically all monads are functors.</li> <li>Monads are programmable semicolons.</li> <li>Monads are like burritos. A functor <code>F</code> takes each type <code>T</code> and     maps it to a new type <code>F(T)</code>. A burrito takes a type, meat or     beans, and turns it into a new type, like beef burrito.<ul> <li>functor: burrito</li> <li>map: you can add onion to beans, so also to a bean burrito</li> <li>pure: the tortilla which lifts any type to a burrito.</li> <li>join: if I had burrito burrito, I can unwrap the inner burrito</li> </ul> </li> <li>Think of monads as statically typed filters in the Unix sense of     \u201cpipes and filters\u201d.</li> <li>In Haskell, <code>main</code> is <code>main :: IO ()</code> or <code>main :: () -&gt; IO ()</code>. So, a     Haskell program is just one big Kleisli arrow in the <code>IO</code> monad.</li> <li>In game programming, when a computer plays against a human, it can\u2019t     predict the opponent\u2019s next move. It can, however, generate a list     of all possible moves and analyze them one by one.</li> <li>A function that has has read-only access to some external state, or      environment, can be always replaced by a function that takes that     environment as an additional argument <code>(a, e) -&gt; b</code>.</li> <li>When is called, The function <code>getChar :: () -&gt; IO Char</code> returns a      character inside a container, and each time it would return exactly     the same container. Conceptually, this container would contain the     superposition of all possible characters. It\u2019s possible compose     <code>getChar</code> with another Kleisli arrow, but this second arrow could     only return his value as an <code>IO a</code> (a supperposition of all possible     <code>a</code> values). There is no <code>runIO</code>.</li> <li>If the program is purely functional, we can mathematically combine     smaller programs to make complex ones and reason about the     soundness and correctness of a program.</li> <li>A Monad is a new type that the language knows how to treat when     composing functions. They can encapsulate side effects or just     purely functional computations and making function composition     possible.</li> <li>Generally, Category Theory helps Computer Science by discovering     \u201ccomputational patterns\u201d. Category Theory discovers them and studies     them in order to find their mathematical properties. Then, Computer     Science can make use of this knowledge in order to empower     developers to create software in a more concise and more correct     way.</li> <li><code>Type ~&gt; Functor ~&gt; Applicative Functor ~&gt; Monad</code><ul> <li><code>fmap :: (a -&gt; b) -&gt; F a -&gt; F b</code> lifts a function. If you will     gave me a blueberry for each apple I gave you <code>(a -&gt; b)</code> ,     and I have a box of apples <code>(F a)</code> , then I can get a box of     blueberries <code>(F b)</code>.</li> <li><code>pure :: a -&gt; M a</code> lifts a type to the M realm, it\u2019s a NT.     If I have an apple <code>(a)</code> then I can put it in a box <code>(M a)</code>.</li> <li><code>(&lt;*&gt;) :: M (a -&gt; b) -&gt; M a -&gt; M b</code> applies a function</li> <li><code>join :: M (M a) -&gt; M a</code> If I have a box of apples <code>M (M a)</code> then I can take the apples from each, and put them in a new     box <code>(M a)</code>.</li> <li><code>(&gt;&gt;=) :: M a -&gt; (a -&gt; M b) -&gt; M b</code> provides a way to compose     functions. It\u2019s a Natural Transformation (NT). If I have a      box of apples <code>(M a)</code> and for each apple you will give me a     box of blueberries <code>(a -&gt; M b)</code> then I can get a box with     all the blueberries together <code>(M b)</code>.     <pre><code>xs &gt;&gt;= f = join (fmap f xs)\n</code></pre></li> </ul> </li> </ul>"},{"location":"Computing/hs-thoughts_monads/#code-examples","title":"Code Examples","text":""},{"location":"Computing/hs-thoughts_monads/#list-monad","title":"List Monad","text":"<pre><code>instance Monad [] where\n    join     = concat\n    return x = [x]\n    as &gt;&gt;= k = concat (fmap k as)\n\nliftM :: (Monad m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b\nliftM f xs = xs &gt;&gt;= (return . f)\nliftM f xs = do x &lt;- xs\n                return (f x)\n</code></pre> <pre><code>instance Monad Maybe where\n    Nothing &gt;&gt;= k = Nothing\n    Just a  &gt;&gt;= k = k a\n    return a      = Just a\n</code></pre>"},{"location":"Computing/hs-thoughts_monads/#state-monad","title":"State Monad","text":"<pre><code>newtype State s a = State (s -&gt; (a, s))\nrunState :: State s a -&gt; s -&gt; (a, s)\nget :: State s s\nput :: s -&gt; State s ()\n\ninstance Monad (State s) where\n    sa &gt;&gt;= k = State (\\s -&gt; let (a, s') = runState sa s\n                            in runState (k a) s')\n    return a = State (\\s -&gt; (a, s))\n</code></pre>"},{"location":"Computing/hs-thoughts_monads/#reader-monad","title":"Reader Monad","text":"<pre><code>newtype Reader e a = Reader (e -&gt; a)\n\ninstance Monad (Reader e) where\n    ra &gt;&gt;= k = Reader (\\e -&gt; runReader (k (runReader ra e)) e)\n    return x = Reader (\\e -&gt; x)\n\nrunReader :: Reader e a -&gt; e -&gt; a\nrunReader (Reader f) e = f e\n</code></pre>"},{"location":"Computing/hs-thoughts_monads/#continuations-dont-call-us-well-call-you","title":"Continuations Don\u2019t call us, we\u2019ll call you!","text":"<pre><code>data Cont r a = Cont ((a -&gt; r) -&gt; r)\n\nrunCont :: Cont r a -&gt; (a -&gt; r) -&gt; r\nrunCont (Cont k) h = k h\n\n-- Our goal is create a function that takes\n-- the handler `(b -&gt; r)` and produces the result `r`.\n-- (&gt;&gt;=) :: ((a -&gt; r) -&gt; r) -&gt;\n--          (a -&gt; (b -&gt; r) -&gt; r) -&gt;\n--          ((b -&gt; r) -&gt; r)\ninstance Monad (Cont r) where\n    ka &gt;&gt;= kab = Cont (\\hb -&gt; runCont ka (\\a -&gt; runCont (kab a) hb))\n    return a = Cont (\\ha -&gt; ha a)\n</code></pre>"},{"location":"Computing/hs-thoughts_monads/#references","title":"REFERENCES","text":"<ul> <li>A monad is just a \u2026</li> <li>The correspondence between Monads in CT and Haskell</li> <li>Monads as containers</li> <li>Monads as computations</li> </ul>"},{"location":"Computing/lowlv-memory/","title":"Understanding memory","text":""},{"location":"Computing/lowlv-memory/#kinds-of-memory-and-its-applications","title":"Kinds of memory and its applications:","text":"<p>Each byte in the memory is addressable</p> <ul> <li><code>Global/static</code>:<ul> <li>Static memory persists throughout the entire life of the program</li> <li>Is usually used to store things like global variables</li> <li>Or variables created with the static clause</li> </ul> </li> <li><code>Stack</code>:<ul> <li>the stack is managed by the CPU</li> <li>It\u2019s a LIFO structure. Every time a function declares a new     variable, it\u2019s \u201cpushed\u201d onto the stack</li> <li>variables are allocated and freed automatically</li> <li>the stack it not limitless \u2013 most have an upper bound</li> <li>the stack grows and shrinks as variables are created and     destroyed</li> <li>stack variables only exist whilst the function that created     them exists</li> </ul> </li> <li><code>Heap</code>:<ul> <li>the heap is managed by the programmer, and is the portion of     memory where dynamically allocated memory resides</li> <li>in <code>C</code>, variables are allocated and freed using functions like     <code>malloc()</code> and <code>free()</code></li> <li>the heap is large, and is usually limited by the physical memory     available</li> <li>the heap requires pointers to access it</li> <li>If all references to allocated memory are lost (e.g. you don\u2019t     store a pointer to it anymore), you have what is called a     memory leak.</li> <li>Unlike the stack where memory is allocated and released in a     very defined order, individual data elements allocated on the     heap are typically released in ways which is asynchronous     from one another.</li> </ul> </li> </ul>"},{"location":"Computing/lowlv-multiprocessing/","title":"Multi Process","text":""},{"location":"Computing/lowlv-multiprocessing/#features-of-threading","title":"Features of Threading","text":""},{"location":"Computing/lowlv-multiprocessing/#benefits-of-threading","title":"Benefits of threading:","text":"<ul> <li>Ease of reading code. The code can run concurrently, but still be     set out in a very simple, top-down linear sequence commands.</li> <li>Parallelism with shared memory. The code can exploit multiple CPUs     while having threads share memory. This is important in many     workloads where it would be too costly to move large amounts of     data between the separate memory spaces of different processes.</li> <li>Know-how and existing code.</li> </ul>"},{"location":"Computing/lowlv-multiprocessing/#drawback-of-threading","title":"Drawback of Threading","text":"<ul> <li>Threading is difficult. Threading bugs and race conditions in     threaded programs are the hardest kind of bugs to fix.</li> <li>Threads are resource-intensive. Threads require extra operating     system resources to create, such as preallocated, per-thread stack     space that consumes process virtual memory up front.</li> <li>Threading can affect throughput. At very high concurrency levels     (i.e &gt;5,000 threads), there can also be an impact on throughput     due to context-switching costs, assuming you can figure out how     to configure your operating system to even allow you to create     that many threads.</li> <li>Threading is inflexible. The operating system share CPU time with     all threads regardless of whether a thread is ready to do work or     not.</li> </ul>"},{"location":"Computing/lowlv-multiprocessing/#features-of-asyncio","title":"Features of <code>Asyncio</code>","text":"<p>For I/O-bound workloads, there are two reasons to use async-bases concurrency over thread-based concurrency:</p> <ul> <li>Asyncio offers a safer alternative to preemptive     multitasking (i.e., using threads) thereby avoiding the bugs, race     conditions, and other nondeterministic dangers that frequently     occur in nontrivial threaded applications.</li> <li>Asycio offers a simple way to support many thousands osf     simultaneous socket connections, including being able to handle     many long-lived connections for newer technologies like     WebSockets, or MQTT for Internet of Things applications.</li> </ul> <p>Threading, as a programming model, is best suited to certain kinds of computational tasks that are best executed with multiple CPUs and shared memory for efficient communication between the threads. The true value of threading lies in being able to write multi-CPU programs, in which different computational tasks can share memory.</p> <p>Asyncio provides another tool for concurrent programming in Python, that is more lightweight than threads or multiprocessing. In a very simple sens it does this by having an event loop execute a collection of tasks, with a key difference being that each task chooses when to yield control back to the event loop.   \u2013 Philip Jones, \u201cUnderstanding Asyncio\u201d</p> <p>The main features that end users should care about are a small subset of the whole asyncio API: - Starting the asyncio event loop - Calling <code>async/await</code> functions - Creating a task to be run on the loop - Waiting for multiple tasks to complete - Closing the loop after all concurrent tasks have completed</p>"},{"location":"Computing/lowlv-multiprocessing/#things-that-asyncio-is-not","title":"Things that Asyncio is not","text":"<ul> <li>Asyncio doesn\u2019t make a code blazing fast</li> <li>Asyncio doesn\u2019t makes threading redundant</li> <li>Asyncio doesn\u2019t removes the problems with the Global Interpreter     Lock (<code>GIL</code>).</li> <li>Asyncio doesn\u2019t prevents all race conditions</li> <li>Asyncio doesn\u2019t make concurrent programming easy. It only makes a     little easyer to avoid certain race condition bugs</li> </ul>"},{"location":"Computing/rust-keywords/","title":"Rust Keywords","text":""},{"location":"Computing/rust-keywords/#conditional-and-loop-structures","title":"Conditional and Loop Structures","text":"<ul> <li>break exit a loop immediately</li> <li>continue continue to the next loop iteration</li> <li>for loop over items from an iterator, implement a trait,     or specify a higher-ranked lifetime</li> <li>in part of for loop syntax</li> <li>loop loop unconditionally</li> <li>while loop conditionally based on the result of an expression</li> <li>if branch based on the result of a conditional expression</li> <li>else fallback for if and if let control flow constructs</li> <li>match match a value to patterns</li> <li>false Boolean false literal</li> <li>true Boolean true literal</li> </ul>"},{"location":"Computing/rust-keywords/#functions-and-variables","title":"Functions and Variables","text":"<ul> <li>fn define a function or the function pointer type</li> <li>return return from function</li> <li>const define constant items or constant raw pointers</li> <li>let bind a variable</li> <li>move make a closure take ownership of all its captures</li> <li>mut denote mutability in references, raw pointers, or     pattern bindings</li> <li>pub denote public visibility in struct fields, impl     blocks, or modules</li> <li>ref bind by reference</li> <li>static global variable or lifetime lasting the entire program     execution</li> </ul>"},{"location":"Computing/rust-keywords/#data-structures-functions-and-variables","title":"Data Structures, Functions and Variables","text":"<ul> <li>enum define an enumeration</li> <li>impl implement inherent or trait functionality</li> <li>Self a type alias for the type implementing a trait</li> <li>self method subject or current module</li> <li>struct define a structure</li> <li>super parent module of the current module</li> <li>trait define a trait</li> <li>type define a type alias or associated type</li> <li>where denote clauses that constrain a type</li> </ul>"},{"location":"Computing/rust-keywords/#modules-and-others","title":"Modules and Others","text":"<ul> <li>as perform primitive casting, disambiguate the specific     trait containing an item, or rename items in use and     extern crate statements</li> <li>crate link an external crate or a macro variable     representing the crate in which the macro is defined</li> <li>extern link an external crate, function, or variable</li> <li>mod define a module</li> <li>use import symbols into scope</li> <li>unsafe denote unsafe code, functions, traits, or implementations</li> </ul>"},{"location":"Computing/rust-ownership/","title":"Rust Ownership","text":""},{"location":"Computing/rust-ownership/#operators","title":"Operators","text":"<pre><code>::          // name-space operator\nself        // Value (owner change)\n&amp;mut self   // Mutable reference (borrow)                               \n&amp;self       // Shared reference (only read)\n</code></pre>"},{"location":"Computing/rust-ownership/#ownership-rules","title":"Ownership rules","text":"<ol> <li>Each value in <code>Rust</code> has a variable that\u2019s called its owner.</li> <li>There can only be one owner at a time.</li> <li>When the owner goes out of scope, the value will be dropped.</li> </ol>"},{"location":"Computing/rust-ownership/#the-rules-of-references","title":"The Rules of References","text":"<ol> <li>At any given time, you can have either one mutable reference or any    number of immutable references.</li> <li>References must always be valid.</li> </ol>"},{"location":"Computing/rust-ownership/#lifetime-rules","title":"Lifetime rules","text":"<ol> <li>Each parameter that is a reference gets its own lifetime parameter.</li> <li>If there is exactly one input lifetime parameter, that lifetime is    assigned to all output lifetime parameters.</li> <li>If there are multiple input lifetime parameters, but one of them is     <code>&amp;self</code> or <code>&amp;mut self</code> the lifetime of self is assigned to all     output lifetime parameters.</li> </ol> <pre><code>let x: i32 = 10;\nlet y: i32 = x; // Copy\n\nlet s1: String = String::from(\"hello\");\nlet s2: String = s1; // Move (not shallow copy)\n//               s1.copy() // Fix the error, allocates in heap\n\nprintln!(\"{}, world!\", s1); // Error\n</code></pre>"},{"location":"Computing/rust-ownership/#lifetime","title":"Lifetime","text":"<p>Let people take pointers to random data on the stack, and the result is a pervasive unmanageable un-safety. It allows to holding a pointer to something that:</p> <ul> <li>went out of scope</li> <li>got mutated away</li> </ul> <p>A lifetime is the name of a region (~block/scope) of code somewhere in  a program.</p> <pre><code>// Only one reference in input, so the output must be derived\n// from that input\nfn foo(&amp;A) -&gt; &amp;B; // sugar for:\nfn foo&lt;'a&gt;(&amp;'a A) -&gt; &amp;'a B;\n\n// Many inputs, assume they're all independent\nfn foo(&amp;A, &amp;B, &amp;C); // sugar for:\nfn foo&lt;'a, 'b, 'c&gt;(&amp;'a A, &amp;'b B, &amp;'c C);\n\n// Methods, assume all output lifetimes are derived from `self`\nfn foo(&amp;self, &amp;B, &amp;C) -&gt; &amp;D; // sugar for:\nfn foo&lt;'a, 'b, 'c&gt;(&amp;'a self, &amp;'b B, &amp;'c C) -&gt; &amp;'a D;\n</code></pre> <p>In practical terms, <code>fn foo&lt;'a&gt;(&amp;'a A) -&gt; &amp;'a B</code> means that the input must live at least as long as the output. If you keep the output around for a long time, this will expand the region that the input must be valid for.</p>"},{"location":"Computing/rust-smartptr/","title":"Rust Smart Pointers","text":"<ul> <li><code>Box&lt;T&gt;</code> - a unique pointer to an object on the heap. Analogous to   C++\u2019s std::unique_ptr.</li> <li><code>Cow&lt;'a, B&gt;</code> - a clone-on-write smart pointer. Useful for when you   have a value that could be borrowed or owned.</li> <li><code>Rc&lt;T&gt;</code> - a shared pointer that provides shared ownership of a value   on a single thread. This smart pointer cannot be sent between threads   safely since it does not use atomic operations to maintain its   refcount (the compiler will make sure you don\u2019t accidentally do   this).</li> <li> <p><code>Arc&lt;T&gt;</code> - very similar to Rc except it uses atomic operations to   update its refcount, and thus is thread-safe. Similar to   std::shared_ptr.</p> </li> <li> <p><code>Pin</code></p> </li> <li> <p><code>MutexGuard</code></p> </li> <li> <p>Cell - A mutable memory location.</p> </li> <li>Ref - Wraps a borrowed reference to a value in a RefCell box. A   wrapper type for an immutably borrowed value from a RefCell. <li>RefCell - A mutable memory location with dynamically checked borrow   rules</li> <li>RefMut - A wrapper type for a mutably borrowed value from a   RefCell. <li> <p>UnsafeCell - The core primitive for interior mutability in Rust.</p> </li> <li> <p><code>Vec&lt;T&gt;/String/PathBuf/OsString</code> et al. - all of these are smart   pointers for owning dynamically allocated arrays of items on the   heap. Read their documentation for more specific details.</p> </li>"},{"location":"Computing/rust-stdlib/","title":"Rust Standard Library","text":""},{"location":"Computing/rust-stdlib/#core-primitive-types","title":"Core Primitive types","text":"<ul> <li>never: The <code>!</code> type, also called \u201cnever\u201d.</li> <li>core::array: A fixed-size array, denoted <code>[T; N]</code>, for the element type,   T, and the non-negative compile-time constant size, N.</li> <li>bool: The boolean type.</li> <li>core::char: A character type.</li> <li>core::f{32, 64}: A floating point type (specifically IEEE 754-2008).</li> <li>fn: Function pointers, like <code>fn(usize) -&gt; bool</code>.</li> <li>core::i{8, 16, 32, 64, 128, size}: The signed integer type.</li> <li>pointer: Raw, unsafe pointers, const T, and mut T.</li> <li>reference: References, &amp;T and &amp;mut T.</li> <li>core::slice: A dynamically-sized view into a contiguous sequence, <code>[T]</code>.   Contiguous here means that elements are laid out so that every element   is the same distance from its neighbors.</li> <li>core::str: String slices.</li> <li>tuple: A finite heterogeneous sequence, <code>(T, U, ..)</code>.</li> <li>core::u{8, 16, 32, 64, 128}: The unsigned integer type</li> <li>unit: The <code>()</code> type, also called \u201cunit\u201d.</li> <li>core::usize: The pointer-sized unsigned integer type.</li> </ul>"},{"location":"Computing/rust-stdlib/#common-types-and-collections","title":"Common types and Collections","text":"<ul> <li>array: Utilities for the array primitive type.</li> <li>core::ascii: Operations on <code>ASCII</code> strings and characters.</li> <li>char: Utilities for the char primitive type.</li> <li>collections: Collection types.</li> <li>fmt: Utilities for formatting and printing <code>Strings</code>.</li> <li>core::hash: Generic hashing support.</li> <li>core::iter: Composable external iteration.</li> <li>core::num: Additional functionality for numerics.</li> <li>core::ops: Overloadable operators.</li> <li>core::option: Optional values.</li> <li>primitive: This module reexports the primitive types to allow usage that     is not possibly shadowed by other declared types.</li> <li>core::result: Error handling with the Result type.</li> <li>slice: Utilities for the slice primitive type.</li> <li>str: Utilities for the str primitive type.</li> <li>string: A <code>UTF-8</code>\u2013encoded, growable string.</li> <li>vec: A contiguous growable array type with heap-allocated contents,     written <code>Vec&lt;T&gt;</code>.</li> </ul>"},{"location":"Computing/rust-stdlib/#smart-pointers-containers-and-memory","title":"Smart Pointers, Containers and Memory","text":"<ul> <li>core::alloc: Memory allocation APIs.</li> <li>core::any: Utilities for dynamic typing or type reflection.</li> <li>core::borrow: A module for working with borrowed data.</li> <li>boxed: The <code>Box&lt;T&gt;</code> type for heap allocation.</li> <li>core::clone: The <code>Clone</code> trait for types that cannot be \u2018implicitly copied\u2019.</li> <li>core::cell: Shareable mutable containers.</li> <li>core::mem: Basic functions for dealing with memory.</li> <li>core::pin: Types that pin data to its location in memory.</li> <li>core::ptr: Manually manage memory through raw pointers.</li> <li>rc: Single-threaded reference-counting pointers. <code>Rc</code> stands for     \u2018Reference Counted\u2019.</li> </ul>"},{"location":"Computing/rust-stdlib/#synchronous-asynchronous-and-concurrency","title":"Synchronous, Asynchronous and Concurrency","text":"<ul> <li>core::future: Asynchronous basic functionality.</li> <li>process: A module for working with processes.</li> <li>core::sync: Useful synchronization primitives.</li> <li>core::task: Types and Traits for working with asynchronous tasks.</li> <li>thread: Native threads.</li> </ul>"},{"location":"Computing/rust-stdlib/#types-and-traits","title":"Types and Traits","text":"<ul> <li>core::cmp: Utilities for comparing and ordering values.</li> <li>core::convert: Traits for conversions between types.</li> <li>core::default: The <code>Default</code> trait for types with a default value.</li> <li>core::marker: Primitive traits and types representing basic properties of     types.</li> </ul>"},{"location":"Computing/rust-stdlib/#io-os-and-network-features","title":"<code>IO</code>, <code>OS</code> and Network features","text":"<ul> <li>core::arch: <code>SIMD</code> and vendor intrinsics module.</li> <li>backtrace: Support for capturing a stack backtrace of an OS thread</li> <li>env: Inspection and manipulation of the process\u2019s environment.</li> <li>error: Interfaces for working with <code>Errors</code>.</li> <li>core::ffi: Utilities related to <code>FFI</code> bindings.</li> <li>fs: Filesystem manipulation operations.</li> <li>core::hint: Hints to compiler that affects how code should be emitted or     optimized. Hints may be compile time or runtime.</li> <li>io: Traits, helpers, and type definitions for core <code>I/O</code> functionality.</li> <li>net: Networking primitives for <code>TCP/UDP</code> communication.</li> <li>os: OS-specific functionality.</li> <li>core::panic: Panic support in the standard library.</li> <li>path: Cross-platform path manipulation.</li> <li>core::time: Temporal quantification.</li> </ul>"},{"location":"Computing/rust-tips/","title":"Rust Tips","text":"<ol> <li>Examples have first-class support in Cargo. Place them in a    directory <code>examples</code> next to <code>src</code>. They can then be run with    <code>cargo run --example foo</code>. They will need to import the crate in    order to use it.</li> <li>Prefer to use <code>module::function</code> instead of importing a free    function directly. This helps the developer track where they come    from. The only exception I make is for <code>min</code> and <code>max</code>.</li> <li>When <code>where</code> clauses are used, they go on a separate line from the    argument and return types, and the opening curly brace does as    well. When there are multiple clauses, each goes on a separate    line.</li> <li>Use trailing commas on arrays and structures. This reduces the    lines of <code>diff</code> when a new <code>struct</code> member is added.</li> <li>Evaluate comments for what consumers of a function need to know    versus what the implementor need to know. Use <code>Rustdoc</code> comments    (<code>///</code>) when talking to the consumer. It\u2019s reasonable to add    <code>Rustdoc</code> for non-public methods, so the consumer may be another    developer of the library.</li> <li>Remove useless documentation like \u201c\u2026 like <code>foo</code> but mutable\u201d.    Don\u2019t repeat information that is described in the function name or    type. Document information that cannot be captured that way.</li> <li>Note that <code>Rustdoc</code> uses <code>Markdown</code>; use <code>Markdwon</code> syntax to refer    to variables as <code>code</code>, for example.</li> <li>Instead of adding comments for each of the \u201cother\u201d cases, write    them out. Generally, annotating something in code is less brittle    that writing it in comments, as the complier checks the former and    not the latter.</li> <li>Instead of a debug assertion, add the explicit patterns it cannot    be and use something like <code>unimplemented!</code>.</li> <li>Prefer regular assertions instead of debug assertions in general;     there\u2019s no worse time for invalid data to occur than in     production. Only switch to debug assertions if profiling shows     that the assertion is adding significant overhead.</li> <li>Instead of dereferencing a value at every use in a loop,     pattern-match to <code>&amp;foo</code>, if the type is <code>Copy</code>.</li> <li>All code should have some tests, doubly so for data structures     that are intended to be used pervasively. The examples also     require a human to look at the output and decide if they are     correct.</li> <li>Check out the <code>|</code> and <code>@</code> aspects of pattern matching. These are     helpful to coalesce duplicate cases (like left/right symmetry) and     to avoid unwrapping and re-wrapping types like <code>Option</code>.</li> <li><code>Unbox</code> usually means to remove a value from a box and free the     box (<code>Box&lt;T&gt; -&gt; T</code>).</li> <li>Look into <code>QuickCheck</code>. Data structures have certain invariants     that should be upheld at all times, and generative testing helps     tease those out.</li> <li>I\u2019d go ahead and make a <code>Node::new</code> to avoid needing to set left     and right to <code>None</code> at the call site.</li> <li>I might prefer <code>while let Some(node) = self.current.as_ref()</code>     versus <code>while let Some(ref node) = *self.current</code>.</li> </ol>"},{"location":"Computing/rust-tips/#references","title":"References","text":"<ul> <li>Performance Book</li> <li>:simple-web: 100,000 Lines of Rust</li> <li>:simple-web: Come for the Foo, stay for the Bar</li> <li>:simple-web: Procedural macros workshop</li> </ul>"},{"location":"Computing/syscalls/","title":"SysCalls","text":""},{"location":"Computing/syscalls/#kinds-of-syscalls","title":"Kinds of SysCalls","text":"<ul> <li>File Management: are responsible for file manipulation such as creating a   file, reading a file, writing into a file etc.</li> <li>Information Maintenance: handle information and its transfer between the   operating system and the user program.</li> <li>Process Control: deal with processes such as process creation, process   termination etc.</li> <li>Device Management: are responsible for device manipulation such as reading   from device buffers, writing into device buffers etc.</li> <li>Signalling: are useful for interprocess communication. They also deal with   creating and deleting a communication connection.</li> </ul>"},{"location":"Computing/syscalls/#references","title":"REFERENCES","text":"<ul> <li>An Introduction to Linux System Calls</li> <li>Linux System Call Table for x86_64</li> <li>LINUX System Call Quick Reference</li> <li>Linux Inside: System Calls</li> </ul>"},{"location":"Finances/acct-basics/","title":"Accountability: Basics","text":""},{"location":"Finances/acct-basics/#the-chart-of-accounts","title":"The Chart of Accounts","text":""},{"location":"Finances/acct-basics/#profit-and-loss-accounts","title":"Profit and Loss Accounts","text":""},{"location":"Finances/acct-basics/#income","title":"Income","text":"<ul> <li> <p><code>goal</code>: accurate reporting of earnings and adherence to financial targets</p> </li> <li> <p>Direct income: comes from the core business activities; sales of goods or services</p> </li> <li> <p>Indirect income: comes from non-core activities; interest, dividends, or rental income</p> </li> </ul>"},{"location":"Finances/acct-basics/#expense","title":"Expense","text":"<ul> <li> <p><code>goal</code>: ensure spending aligns with budgets and financial plans, avoid unnecessary costs</p> </li> <li> <p>Direct expense: costs directly tied to the production of goods or services; raw materials and labor.</p> </li> <li> <p>Indirect expense: overhead costs not directly tied to production; utilities, rent, and administrative salaries</p> </li> </ul>"},{"location":"Finances/acct-basics/#balance-sheet-accounts","title":"Balance Sheet Accounts","text":""},{"location":"Finances/acct-basics/#asset","title":"Asset","text":"<ul> <li> <p><code>goal</code>: keep an accurate record of their value and ensure they are bening used efficiently and protected</p> </li> <li> <p>Current assets: short-term assets that can be easily converted into cash within a year; inventory, receivables or a highly liquid designated fund</p> </li> <li> <p>Fixed assets: long-term tangible assets; property, equipment, investments and machinery used in operations</p> </li> </ul>"},{"location":"Finances/acct-basics/#liability","title":"Liability","text":"<ul> <li> <p><code>goal</code>: monitor due dates and make timely payments</p> </li> <li> <p>Current liability: short-term obligations due within a year; accounts payable and short-term loans</p> </li> <li> <p>Fixed liability: long-term obligations due after a year; mortgages and bonds payable</p> </li> </ul>"},{"location":"Finances/acct-basics/#equitiy-accounts","title":"Equitiy Accounts","text":""},{"location":"Finances/acct-basics/#other-accounts","title":"Other Accounts","text":"<ul> <li>Fondo fijo de caja</li> <li>Caja general </li> <li>Bancos</li> <li>Clientes</li> <li>Documentos por cobrar</li> <li>Deudores</li> <li>(fix-as) Almacen</li> <li>(cur-as) Anticipo de impuestos</li> <li>anticipo a proveedores</li> <li>IVA por acreditar</li> <li>IVA acreditable</li> <li>Terreno</li> <li>Pagos anticipados: pagos anticipados de periodos contables futuros</li> <li>Proveedores: compras de mercanc\u00eda a cr\u00e9dito</li> <li>Acreedores: compras distintas a mercanc\u00edas o servicios, prestamos recibidos</li> <li>Documentos por pagar: compras distintas a mercancias o servicios \u00fanicamente a cr\u00e9dito</li> <li>Impuestos por pagar</li> <li>IVA pendiente de causar</li> <li>IVA causado</li> <li>Documentos por pagar a largo plazo</li> <li>Capital social: aportaciones que efectuan los socios o accionistas</li> <li>Aportaciones para futuros aumentos de capital</li> <li>Utilidades acumuladas: cambios por traspasos de utilidades netas del ejercicio</li> <li>Utilidad del ejercicio: cambios que experimenta la utilidad neta</li> <li>Reserva legal: cambios por creaci\u00f3n de reservas</li> <li>Ingresos por venta</li> <li>Descuentos y Reb. S/Venta: cambios por mercanc\u00eda que los clientes devuelven</li> <li>Compras: operaciones de mercancias a contado o credito que constituyen el giro principal de la entidad</li> <li>Descuentos y Reb. S/Compra: mercanc\u00edas que la empresa devuelve fisicamente a sus proveedores</li> <li>Gastos de venta: gastos que la empresa realiza con la finalidad de incrementar el volumen de ventas</li> <li>Gastos de administracion: gastos relacionados con las personas y oficinas encargadas de la administraci\u00f3n</li> <li>Otros Ingresos: operaciones inidentales, utilidad de venta de activo fijo, donaciones</li> <li> <p>Otros Gastos: perdidas en venta de inmuebles, maquinaria, equipo e intangibles</p> </li> <li> <p>Edificios</p> </li> <li>Depreciaci\u00f3n acum. de edificios</li> <li>Mobiliario y Equipo de oficina</li> <li>Depreciaci\u00f3n acum. de Equipo de oficina</li> <li>Maquinaria y Equipo</li> <li>Depreciaci\u00f3n acum. de Maquinaria y Equipo</li> <li>Equipo de transporte</li> <li>Depreciaci\u00f3n acum. de transporte</li> <li>Equipo de computo</li> <li> <p>Depreciaci\u00f3n acum. de Equipo de computo</p> </li> <li> <p>Contabilidad:</p> <ul> <li>que? estudia, mide y analiza la situaci\u00f3n econ\u00f3mica de una empresa</li> <li>para? facilitar la toma de decisiones dentro de la misma</li> <li>como? presentando la informaci\u00f3n de manera sistem\u00e1tica y \u00fatil</li> </ul> </li> <li>Objetivos de la contabilidad:<ul> <li>analizar los recursos econ\u00f3micos de una empresa</li> <li>permitir a los administradores una correcta planificaci\u00f3n de las transacciones comerciales</li> <li>controlar y llevar un registro de las gestiones de los administradores </li> </ul> </li> <li>Empresa:<ul> <li>que? organizaci\u00f3n de personas y recursos que busca un beneficio ecn\u00f3mico</li> <li>como? mediante el desarrollo de una actividad en particualar</li> </ul> </li> </ul>"},{"location":"Humanities/gramatica_fantasia/","title":"Gram\u00e1tica de la Fantas\u00eda - Rodari","text":"<ul> <li>Juego de la china: Partiendo de una palabra, explorarla. Obtener cadenas de   palabras por cercan\u00eda f\u00f3nica. Indagar si tiene polisemia. Crear acr\u00f3sticos.   Una analog\u00eda verbal puede sucitar una met\u00e1fora.</li> <li>El prefijo arbitrario: Se modifica una palabra agregandole un prefijo   cualquiera.</li> <li>El error creativo: Aprovechar el error ortogr\u00e1fico como una creaci\u00f3n   aut\u00f3noma. Los ni\u00f1os suelen saltar de una palabra desconocida a una conocida   por familiaridad f\u00f3nica, y esto para asimilar una realidad desconocida.</li> <li>El binomio fant\u00e1stico: Aqu\u00ed las palabras no son tomadas en su significado   cotidiano, sino liberadas de las cadenas verbales de las que forman parte   cotidianamente. Enlazarlas con una preposici\u00f3n y los correspondientes   art\u00edculos. Crear contexto para dos sustantivos.</li> <li>La trama fant\u00e1stica: Se eligen al azar un sujeto y un predicado. Su uni\u00f3n   proporcionar\u00e1 la hip\u00f3tesis fant\u00e1stica sobre la cual trabajar. \u00bfQu\u00e9 pasar\u00eda   si\u2026</li> <li>La sintaxis fant\u00e1stica: Se elige una serie de preguntas al azar (\u00bfQui\u00e9n   era?, \u00bfd\u00f3nde estaba?, \u00bfqu\u00e9 hac\u00eda?, \u00bfqu\u00e9 dijo?, etc). El movimiento del   nonsense al sentido.</li> <li>Tratamiento de un verso: Elegir alg\u00fan verso y reescribirlo deform\u00e1ndolo, en   la b\u00fasqueda de un tema fant\u00e1stico. El ejercicio es para adiestrar a la   imaginaci\u00f3n de apartarse de los caminos demasiado comunes de significado.</li> <li>Falsa adivinanza: Es aquella que contiene ya de uno u otro modo su   respuesta.</li> <li>La doble ca\u00edda: Del rito a lo laico, de lo laico al juego (M\u00e1scara ritual,   traje teatral, marioneta).</li> <li>Decodificar el lado c\u00f3mico: Interpretar la historia, dando la resoluci\u00f3n   c\u00f3mica frente a la pat\u00e9tica.</li> <li> <p>An\u00e1lisis fant\u00e1stico: Sobre un personaje de cuento, consistir\u00e1 en   descmponerlo en sus factores primarios, con el fin de rastrear los elementos   para la construcci\u00f3n de nuevos binomios fant\u00e1sticos. Esto es, inventar   nuevas historias en torno al personaje. El personaje elegido puede ser   conocido (Pulgarcito), arquet\u00edpico (el vaquero, el brujo) o producto de un   binomio (el hombre de vidrio). Sus aventuras pueden deducirse de sus   caracter\u00edsticas.</p> </li> <li> <p>Construcci\u00f3n de un Limerick <code>-&gt;</code></p> <ol> <li>Elecci\u00f3n del protagonista</li> <li>Indicaci\u00f3n de una cualidad, expresada con una acci\u00f3n</li> <li>Realizaci\u00f3n del predicado en el 3\u00ba y 4\u00ba verso</li> <li>Elecci\u00f3n del ep\u00edteto final</li> <li>Rima <code>AABBA</code></li> </ol> </li> <li> <p>Construcci\u00f3n de una adivinanza <code>-&gt;</code></p> <ol> <li>Extra\u00f1amiento, definir al objeto como visto por primera vez</li> <li>Asociaci\u00f3n, de la definici\u00f3n crear aperturas a otros significados a partir de im\u00e1genes por analog\u00eda o comparaci\u00f3n</li> <li>Met\u00e1fora, crear una nueva definici\u00f3n metaf\u00f3rica</li> </ol> </li> <li> <p>Tratamiento de cuentos <code>-&gt;</code></p> <ul> <li>Binomio, usar al cuanto como el primer t\u00e9rmino del binomio y a una   palabra inesperada como el segundo</li> <li>\u00bfQu\u00e9 ocurre despu\u00e9s?, partiendo de las reglas internas del cuento y   mediante una nueva palabra, crear una continuaci\u00f3n</li> <li>Los cuentos al rev\u00e9s, invertir los valores de los personajes, trama</li> <li>Ensalada de cuentos, usar a un cuento como un t\u00e9rmino del binomio y a   otro como el otro</li> <li>Imitando cuentos, usar al cuento como un complejo sistema de coordenadas   fant\u00e1sticas.</li> <li>Transformaci\u00f3n de un tema, por reducci\u00f3n, amplificaci\u00f3n, sustituci\u00f3n e   intensificaci\u00f3n</li> </ul> </li> <li> <p>Principios de Propp <code>-&gt;</code></p> <ul> <li>Los elementos constantes son las funciones de los personajes</li> <li>El n\u00famero de funciones que incluye el cuento es limitado</li> <li>La sucesi\u00f3n de funciones es siempre id\u00e9ntica</li> <li>Funciones: alejamiento, prohibici\u00f3n, transgreci\u00f3n, interrogatorio,   informaci\u00f3n, enga\u00f1o, complicidad, fechor\u00eda, mediaci\u00f3n, principio de la   acci\u00f3n contraria, partida, primera funci\u00f3n del donante, reacci\u00f3n del   h\u00e9roe, recepci\u00f3n del objeto m\u00e1gico, desplazamiento, combate, marca,   victoria, reparaci\u00f3n, la vuelta, persecuci\u00f3n, socorro, llegada de   inc\u00f3gnito, pretensiones enga\u00f1osas, tarea dif\u00edcil, tarea cumplida,   reconocimiento, descubrimiento, transfiguraci\u00f3n, castigo, matrimonio.</li> </ul> </li> </ul>"},{"location":"Humanities/poesia_reglas/","title":"Formas de verso rimado","text":"<ul> <li>haiku: 5-7-5 (a veces <code>AXA</code>)</li> <li>tanka: 5-7-5-7-7 (en el verso 3\u00ba debe haber una imagen de enlace)</li> <li>limerick: <code>8a-8a-5b-5b-8a</code></li> <li>clerihew: <code>AABB</code></li> <li>copla: grupo de cuatro octos\u00edlabos, con rima asonante en los pares</li> <li>cuarteto: estrofa de cuatro versos en arte mayor, con rima consonante ABBA</li> </ul>"},{"location":"Humanities/tango_orchestras/","title":"Main tango orchestras by composer","text":""},{"location":"Humanities/tango_orchestras/#francisco-canaro-1888-1964","title":"Francisco Canaro (1888-1964)","text":""},{"location":"Humanities/tango_orchestras/#juan-darienzo-1900-1976","title":"Juan D\u2019Arienzo (1900-1976)","text":""},{"location":"Humanities/tango_orchestras/#carlos-di-sarli-1903-1960","title":"Carlos di Sarli (1903-1960)","text":""},{"location":"Humanities/tango_orchestras/#osvaldo-pugliese-1905-1995","title":"Osvaldo Pugliese (1905-1995)","text":""},{"location":"Humanities/tango_orchestras/#anibal-troilo-1914-1975","title":"Anibal Troilo (1914-1975)","text":""},{"location":"Humanities/tango_orchestras/#astor-piazzolla-1933-1990","title":"Astor Piazzolla (1933-1990)","text":""},{"location":"Humanities/tango_paola_class/","title":"Tango practice with Paola","text":""},{"location":"Humanities/tango_paola_class/#friday-21june2024","title":"Friday 21/June/2024","text":"<ul> <li>Excercises:<ul> <li>Dance with a pen: A tango song is played and the student must \u201cdance\u201d by   tracing on paper. The objective is to observe the musical elements to   which the student pays the most attention.</li> <li>Hold the embrace structure: During three tango songs, the student must   form the structure of the hug (close ribs, vascularize the hip, relaxed   knees, open back, stretched spine) while holding the two ends of a rope,   keeping it taut. The purpose of the rope is to show if the activation of   the hug is lost.</li> <li>Listen by sight: Given a tango video (preferably a competition one with   multiple couples dancing), put the audio on mute and try to discern what   genre is being danced (tango, milonga, valz). Extra points if you can   argue which orchestra it could be.</li> </ul> </li> <li>Notes:<ul> <li>Steps need to be longer.</li> <li>Walk with a normal cadence; without over-tensioning.</li> <li>Do not generate noise when sliding the foot.</li> </ul> </li> </ul>"},{"location":"Humanities/tp-lexical_categories/","title":"Toki Pona: Lexicographic classification","text":""},{"location":"Humanities/tp-lexical_categories/#grammar","title":"Grammar","text":"WORD MEANING a interjection o vocative, imperative anu or en and e direct-object la then;context, subclause li predicate pi description-modifier kin also, too lon at, exists ni this, that seme what, question-marker tan because, causality taso but, only"},{"location":"Humanities/tp-lexical_categories/#counting","title":"Counting","text":"WORD MEANING nanpa number ala zero, nothing wan one tu tu luka five mute many ali all, infinite"},{"location":"Humanities/tp-lexical_categories/#nature","title":"Nature","text":"WORD MEANING akesi repitle, amphibious kala fish pipi insect soweli animal waso bird, winged-animal kiwen rock kon air seli fire telo water kasi plant, tree kili fruit pan cereal soko mushroom mun moon suno sun"},{"location":"Humanities/tp-lexical_categories/#position","title":"Position","text":"WORD MEANING anpa down, below sewi up, above insa inside poka side, vicinity monsi back, behind sinpin front lon in, on"},{"location":"Humanities/tp-lexical_categories/#geometry","title":"Geometry","text":"WORD MEANING sijelo figure leko block, square linja line, string palisa long-hard-object sike ball, circle selo boundary, surface supa horizontal, table lupa hole, pit, door nena ridge, peak, hill"},{"location":"Humanities/tp-lexical_categories/#body","title":"Body","text":"WORD MEANING sijelo body selo skin lawa head, lead lukin eye, see oko eye kute ear, listen uta mouth, lips insa stomach, viscera poka side, hip monsi back sinpin front luka hand, arm noka foot, leg"},{"location":"Humanities/tp-lexical_categories/#people","title":"People","text":"WORD MEANING jan person meli woman, female mije man, male tonsi non-binary mama parent, ancestor pata sibling, relative mi I, me, we, us sina you ona he, she, it, they"},{"location":"Humanities/tp-lexical_categories/#colours","title":"Colours","text":"WORD MEANING kule color jelo yellow laso blue, green loje red pimeja black, dark walo white"},{"location":"Humanities/tp-lexical_categories/#antonyms","title":"Antonyms","text":"ANTONYM MEANING ante:sama equal:different pona:ike good:bad lete:seli cold:hot lili:suli little:big sin:majuna new:old meli:mije female:male open:pini begin:end anpa:suwi down:up walo:pimeja white:black suno:pimeja light:darkness"},{"location":"Mathematics/alg-combinatoria_a/","title":"Combinatoria 1","text":""},{"location":"Mathematics/alg-combinatoria_a/#reglas-aditivas","title":"Reglas aditivas","text":"<p>Si hay \\(n(A)\\) maneras de hacer \\(A\\) y \\(n(B)\\) maneras de hacer \\(B\\), siendo mutuamente independientes, entonces: </p> <ul> <li>Regla de la suma: el n\u00famero de maneras de hacer \\(A\\) o \\(B\\) es \\(n(A) + n(B)\\).</li> <li>Regla del producto: el n\u00famero de maneras de hacer \\(A\\) y \\(B\\) es \\(n(A) * n(B)\\).</li> </ul>"},{"location":"Mathematics/alg-combinatoria_a/#permutaciones","title":"Permutaciones","text":"<p>Una permutaci\u00f3n es un arreglo de \\(r\\) objetos tomados de un conjunto de \\(n\\) objetos. El orden importa. El n\u00famero de permutaciones posibles es:</p> \\[P(n, k) = \\frac{n!}{(n-k)!}\\] <p>En general, si existen \\(n\\) objetos con \\(n_1\\) de un primer tipo, \\(n_2\\) de un segundo tipo y \\(n_k\\) de un \\(r\\)-\u00e9simo tipo, d\u00f3nde \\(n_1 + n_2 + \\dots + n_k = n\\), entonces existen \\(\\frac{n!}{n_1! n_2! \\dots n_k}\\) disposiciones (lineales) de los \\(n\\) objetos dados. Los objetos del mismo tipo son indistinguibles.</p>"},{"location":"Mathematics/alg-combinatoria_a/#combinaciones","title":"Combinaciones","text":"<p>El coeficiente binomial \\(C(n, k)\\) es cualquier subconjunto de \\(k\\) elementos tomado de un conjunto con \\(n\\) elementos. El orden no importa. Su n\u00famero est\u00e1 dado por la formula:</p> \\[C(n, k) = \\binom{n}{k} = \\frac{n!}{k!(n - k)!} = \\frac{P(n, k)}{k!}\\] <p>El conjunto potencia de un conjunto \\(A\\), \\(\\rho(A)\\), es el conjunto que incluye todos los posibles subconjuntos de \\(A\\). Su cardinalidad se calcula sumando el n\u00famero de combinaciones que resulta de ir incrementando el tama\u00f1o de los subconjuntos.</p> \\[|\\rho(A)| = \\sum_{k=0}^n \\binom{n}{k},n = |A|\\] <p>El teorema del binomio describe la expansi\u00f3n algebraica de la \\(n\\)-\u00e9sima potencia de un binomio, siendo \\(n \\in \\mathbb{Z}^+\\).</p> \\[(x + y)^n = \\sum_{k=0}^n \\binom{n}{k} x^{n-k} y^k\\] <p>Combinando ambos conceptos, se llega a la conclusi\u00f3n de que la cardinalidad del conjunto potencia de \\(A\\) se puede calcular con \\(2^n\\), siendo \\(n = |A|\\).</p> \\[\\begin{aligned}     (1 + 1)^n   &amp;= \\sum_{k=0}^n \\binom{n}{k} 1^{n-k} 1^k \\\\     2^n         &amp;= \\sum_{k=0}^n \\binom{n}{k} \\\\     2^n         &amp;= |\\rho(A)| \\\\ \\end{aligned}\\] \\[\\log(a, b, p) = \\begin{cases}     0 \\quad &amp;, a = 1 \\\\     x \\quad &amp;, p = 0 \\\\     x + \\frac{\\log( , b, p-1)}{10} \\\\ \\end{cases} \\:\\text{where}\\: x = \\mathrm{BiPLE}(b, a)\\]"},{"location":"Mathematics/cat-basic_definitions/","title":"Definitions of Abstract Algebra","text":""},{"location":"Mathematics/cat-basic_definitions/#algebras","title":"Algebras","text":"<ul> <li>An algebra is defined by:<ol> <li>A set of values</li> <li>A set of operations</li> <li>A set of laws</li> </ol> </li> <li>A semigroup, monoid or group is a kind of algebra with     a defined binary operator \\(\\ast\\)</li> </ul> if \\(\\ast\\) Semigroup Monoid Group Abelian is closed T T T T is associative T T T T has identity F T T ? has inverse F F T ? is commutative ? ? ? T"},{"location":"Mathematics/cat-basic_definitions/#examples","title":"Examples","text":"<ul> <li>Z, Q, R and C are abelian groups under addition,     and abelian monoids under multiplication, because the     \\(0\\) doesn\u2019t have inverse.</li> <li>The set of all \\(2 x 2\\) matrices with real entries     form a monoid under multiplication (many singular matrices).</li> <li>The dihedral group:     \\(D_4 = \\{I, R, R^2, R^3, T_x, T_y , T_{1,3}, T_{2,4}\\}\\)</li> </ul>"},{"location":"Mathematics/cat-basic_definitions/#functor","title":"Functor","text":"<ul> <li>Functor is another kind of algebra</li> <li>A functor consists of:<ol> <li>A Container Type \\(f\\) that holds values of type \\(a\\)</li> <li>A function \\(fmap\\) that takes a function an lifts it</li> </ol> </li> <li>The Functor Laws<ol> <li>Identity      <code>fmap id == id</code></li> <li>Composition      <code>fmap (f.g) == (fmap f) . (fmap g)</code></li> <li>Structure preservation      <code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code></li> </ol> </li> </ul>"},{"location":"Mathematics/cat-basic_definitions/#applicative","title":"Applicative","text":"<ul> <li>The Applicative Laws:<ol> <li>Identity     <code>pure id &lt;*&gt; v == v</code></li> <li>Homomorphism     <code>pure f &lt;*&gt; pure x == pure (f x)</code></li> <li>Interchange     <code>u &lt;*&gt; pure y == pure ($ y) &lt;*&gt; u</code></li> <li>Composition     <code>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w == u &lt;*&gt; (v &lt;*&gt; w)</code></li> </ol> </li> <li>Applicatives are more composable than Monads.</li> </ul>"},{"location":"Mathematics/cat-basic_definitions/#monads","title":"Monads","text":"<ul> <li>The Monad Laws:<ol> <li>Left identity     <code>pure &lt;=&lt; f == f</code></li> <li>Right identity     <code>f &lt;=&lt; pure == f</code></li> <li>Associativity     <code>f &lt;=&lt; (g &lt;=&lt; x)== (f &lt;=&lt; g) &lt;=&lt; x</code></li> </ol> </li> <li>Every Monad is Applicative, and every Applicative is a     Functor, but said the opposite isn\u2019t always true.</li> <li>These are similar to the monoid laws, but generalized     for multiple types defined inside the monad. This sort     of structure is called a category in mathematics.</li> </ul>"},{"location":"Mathematics/cat-basic_definitions/#summarize","title":"Summarize","text":"<ul> <li>Functors are types for containers where we can <code>map</code>     pure functions on their contents.</li> <li>Applicative Functors are types where we can combine     \\(n\\) containers with a \\(n\\)-ary function.</li> <li>Monads are types <code>m</code> where we can sequentially compose     functions of the form <code>a -&gt; m</code>.</li> </ul>"},{"location":"Mathematics/cat-categories_haskell/","title":"Categories in Haskell","text":""},{"location":"Mathematics/cat-categories_haskell/#category-theory-as-a-theory-about-composition","title":"Category Theory as a theory about Composition","text":"<p>Some time ago the principles of structured programming revolutionized programming because they made blocks of code composable. Then came object oriented programming, which is all about composing objects. Functional programming is not only about composing functions and algebraic data structures; it makes concurrency composable, somethings that\u2019s virtually impossible in other programming languages.</p> <p>Functional programming is a subset of a more important overaching programming paradigm: compositional programming. Category Theory codifies this compositional style in a design pattern: the category. Unlike other design patterns, the category laws provides rigorous criteria for what does and does not qualify as compositional.</p>"},{"location":"Mathematics/cat-categories_haskell/#definitions","title":"Definitions","text":"<p>A Category is a two-sorted structure that encodes the algebra of composition. It has - objects - arrows - each pair of composable arrows has a composite arrow. - each object has an identity arrow for which the     composition operation is associative and unital.</p> <p>Isomorphism invariance principle: If \u2018A\u2019 and \u2018B\u2019 are isomorphic then every category theoretic property of \u2018A\u2019 is also true of \u2018B\u2019</p>"},{"location":"Mathematics/cat-categories_haskell/#examples-of-categories","title":"Examples of categories","text":"<ul> <li>The category Set: objects are (finite) sets and arrows     are functions.</li> <li>The syntactic category for some programming languages:     objects are types and arrows are programs.</li> </ul> <p>The categorical imperative \u201cprograms should form a category\u201d leads to the notion of monad.</p>"},{"location":"Mathematics/cat-categories_haskell/#category-laws","title":"Category Laws","text":"<p>Category theory says that for any given category there must be some sort of composition operator, say (\u00b7).</p> <p>Composition means we can omit arrows that can be deduced.</p> <ul> <li> <p>First Law: This composition operator is associative <pre><code>f \u00b7 (g \u00b7 h) = (f \u00b7 g) \u00b7 h\n</code></pre></p> </li> <li> <p>Second Law: This composition operator must have a left and     right identity <pre><code>I \u00b7 f = f\nf \u00b7 I = f\n</code></pre></p> </li> </ul>"},{"location":"Mathematics/cat-categories_haskell/#the-function-category-in-haskell","title":"The function category in Haskell","text":"<pre><code>id :: a -&gt; a\nid x = x\n\n(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)\nf . g = \\x -&gt; f (g x)\n\n{-- Associativity\n    (f . g) . h\n    == \\x -&gt; (f . g) . (h x)\n    == \\x -&gt; f (g (h x))\n    == \\x -&gt; f ((g . h) x)\n    == \\x -&gt; (f . (g . h)) x\n    == f . (g . h)\n-}\n</code></pre>"},{"location":"Mathematics/cat-categories_haskell/#the-kleisli-category-in-haskell","title":"The Kleisli category in Haskell","text":"<p>This is the category of monadic functions, which generalize ordinary functions. Mathematicians call this the \u201cKleisli\u201d category, and <code>Control.Monad</code> provides this two functions. Monadic functions just generalize ordinary functions and the Kleisli category demonstrates that monadic functions are composable, too.</p> <pre><code>return  :: Monad m =&gt; a -&gt; m a\n(&lt;=&lt;)   :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c)\n\n-- Compare both categories\nid     ::              (a -&gt;   a)\nreturn :: (Monad m) =&gt; (a -&gt; m a)\n\n(.)    ::              (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; (a -&gt;   c)\n(&lt;=&lt;)  :: (Monad m) =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c)\n\n(f  .  g) x = f     (g x)\n(f &lt;=&lt; g) x = f =&lt;&lt; (g x)\n</code></pre>"},{"location":"Mathematics/cat-categories_haskell/#from-kleisli-to-monad-laws","title":"From Kleisli to Monad Laws","text":"<pre><code>-- The Category Laws in Kelisli\nreturn &lt;=&lt; f    == f                -- Left  identity\nf &lt;=&lt; return    == f                -- Right identity\n(f &lt;=&lt; g) &lt;=&lt; h == f &lt;=&lt; (g &lt;=&lt; h)  -- Associativity\n\n-- Using (=&lt;&lt;) from the definition of (&lt;=&lt;)\nreturn =&lt;&lt; (f x)            == (f x)\nf =&lt;&lt; (return x)            == f x\n(\\y -&gt; f =&lt;&lt; (g y)) =&lt;&lt; h x == f =&lt;&lt; (g =&lt;&lt; (h x))\n\n-- Using (&gt;&gt;=) to flip the order of arguments\nm &gt;&gt;= return            == m\nreturn x &gt;&gt;= f          == f x\nm &gt;&gt;= (\\y -&gt; g y &gt;&gt;= f) == (m &gt;&gt;= g) &gt;&gt;= f\n</code></pre>"},{"location":"Mathematics/cat-categories_haskell/#references","title":"References","text":"<ul> <li>Peeling the banana: Recursion Schemes from first principles</li> <li>The Category design Pattern</li> </ul>"},{"location":"Mathematics/cat-functor/","title":"Functors and Applicatives","text":""},{"location":"Mathematics/cat-functor/#functors","title":"Functors","text":"<p>Uniform action over a parametrized type, generalizing the map function on lists. A functor transforms one category into another category. Functors arise every time we write compatibility layers and adapters between different pieces of software. In Haskell, the Functor class only encompass  the narrow case where the source and target categories are both categories of ordinary functions</p> <pre><code>class Functor f where\n    fmap :: (a -&gt; b) -&gt; f a -&gt; f b\n    (&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b\n\n-- map id       == id               identity\n-- map (f . g)  == map f . map g    composition\n</code></pre> <p>It is possible generalize the <code>fmap</code> function.</p> <pre><code>pure :: a -&gt; f a\n(&lt;*&gt;):: f (a -&gt; b) -&gt; f a -&gt; f b\n\nfmap0 :: a -&gt; f a\nfmap0 = pure\n\nfmap1 :: (a -&gt; b) -&gt; f a -&gt; f b\nfmap1 g x = pure g &lt;*&gt; x\n\nfmap2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; b c\nfmap2 g x y = pure g &lt;*&gt; x &lt;*&gt; y\n</code></pre>"},{"location":"Mathematics/cat-functor/#the-functor-laws-covariant-functor-laws","title":"The Functor Laws (covariant functor laws)","text":"<ul> <li>The identity law: must transform the identity in the source      category to the identity in the destination category.</li> <li>The compose law: must transform the composition operator in     the source category to the composition operator in the destination      category.</li> </ul>"},{"location":"Mathematics/cat-functor/#applicative","title":"Applicative","text":"<p>Map function in a context to the value in a context. The <code>&lt;*&gt;</code> operator generalize the <code>fmap</code> function. Can be chained together. All Applicative instances must also be Functor instances.</p> <pre><code>class (Functor f) =&gt; Applicative f where\n    pure :: a -&gt; f a\n    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b\n</code></pre> <p>When one uses a monad transformer it\u2019s possible appreciate that we are using a functor as an adapter layer between two categories: the base monad\u2019s Kleisli category and the transformed monad\u2019s Kleisli category.</p> <p>The functor design pattern embodies a philosophy of programming that emphasizes: - compatibility over standardization - specialization over monolithic frameworks - short-term completion over future-proofing</p>"},{"location":"Mathematics/cat-functor/#the-application-laws","title":"The Application Laws","text":"<pre><code>pure &lt;*&gt; id x   == x\npure (g x)      == pure g &lt;*&gt; pure x\nx &lt;*&gt; pure y    == pure (\\g -&gt; g y) &lt;*&gt; x\nx &lt;*&gt; y &lt;*&gt; z   == (pure (.) &lt;*&gt; x &lt;*&gt; y) &lt;*&gt; z\n\n-- Proof of 1st law\npure &lt;*&gt; id x\n(\\x -&gt; (\\y -&gt; x)) id &lt;*&gt; x  -- by def of pure\n(\\y -&gt; id) &lt;*&gt; x\n\\z -&gt; (\\y -&gt; id) z (x z)    -- by def of &lt;*&gt;\n\\z -&gt; id (x z)              -- using partial function application\n\\z -&gt; x z\n\n-- Prof of 2nd law\npure (g x)                  -- LEFT HAND SIDE\n\\y -&gt; g x                   -- by def of pure\npure g &lt;*&gt; pure x           -- RIGHT HAND SIDE\n\\y -&gt; g &lt;*&gt; \\z -&gt; x         -- by def of pure\n\\t -&gt; (\\y -&gt; g) t ((\\z -&gt; x) t) -- by def of &lt;*&gt;\n\\t -&gt; (\\y -&gt; g) t x\n\\t -&gt; g x\n\n-- Proof of 3rd law\nx &lt;*&gt; pure y                -- LEFT HAND SIDE\nx &lt;*&gt; \\z -&gt; y\n\\t -&gt; x t ((\\z -&gt; y) t)     -- by def of &lt;*&gt;\n\\t -&gt; x t y\npure (\\g -&gt; g y) &lt;*&gt; x      -- RIGHT HAND SIDE\n\\z -&gt; (\\g -&gt; g y) &lt;*&gt; x\n\\t -&gt; (\\z -&gt; (\\g -&gt; g y)) t (x t)-- by def of &lt;*&gt;\n\\t -&gt; (\\g -&gt; g y) (x t)\n\\t -&gt; x t y\n\n-- Proof of 4th law\nx &lt;*&gt; (y &lt;*&gt; z)             -- LEFT HAND SIDE\nx &lt;*&gt; (\\t -&gt; y t (z t))\n\\g -&gt; x g ((\\t-&gt; y t (z t)) g)\n\\g -&gt; x g (y g (z g))\n(pure (.) &lt;*&gt; x &lt;*&gt; y) &lt;*&gt; z-- RIGHT HAND SIDE\n((\\t -&gt; (.) (x t)) &lt;*&gt; y) &lt;*&gt; z\n(\\g -&gt; ((.) (x g)) (y g)) &lt;*&gt; z\n\\v -&gt; x v ((y v) (z v))\n</code></pre>"},{"location":"Mathematics/cat-higher_kinded_types/","title":"Higher-Kinded Types (HKT)","text":"<p>A higher kinded type is a concept that reifies a type constructor as an  actual type.</p> <p>A type constructor can be thought of in these analogies:</p> <ul> <li>like a function in the type universe</li> <li>as a type with a \u201chole\u201d in it</li> <li>as a container containing type(s)</li> <li>as a generic type, parameterised over other types</li> <li>as an endofunctor in the category of types</li> </ul> <p>To be able to use them in places where concrete \u201cproper\u201d types are usually  expected, a language must support the concept of higher kinded types.</p> <p>There are 3 keywords in \u201chigher kinded types\u201d:</p> <ul> <li> <p>Higher: The \u201chigher\u201d prefix is derived from the phrase \u201chigher order\u201d. In   terms of programming, it usually refers to a function that can at least take   other functions as input, or return functions as output. However I think in   this case, the prefix has become more general, and refers to a form of   recursive containment. Basically it\u2019s the idea that a type could contain   other types. See concepts like \u201chigher order messages\u201d. This makes sense, and   seems to define they very concept of type constructors and/or recursive data   structures. Here we use the word \u201ccontain\u201d to mean parameterisation of things   related to itself, and/or returning of things related to itself. Refer to 1st   order and 2nd order logic literature for more:</p> </li> <li> <p>Kinded: Kinds are the types of types. Most \u201cproper\u201d types have a kind   signature of <code>*</code>. But higher order types, or type constructors could have a   kind signature of <code>* -&gt; *</code>. The ability of having higher kinds defines a type   constructor.</p> </li> <li> <p>Types: Finally of course I believe this term signifies a reification of   our type constructors as a first class type that can be manipulated using the   same tools that we manipulate normal <code>*</code> \u201cproper\u201d types.</p> </li> </ul>"},{"location":"Mathematics/cat-higher_kinded_types/#haskell","title":"Haskell","text":"<p>Haskell has good support for higher kinded types. Every type constructor such as  they <code>[]</code> can be used as a \u201cfirst class type\u201d.</p> <p>This is specifically relevant to typeclasses such as the <code>Functor</code> typeclass.</p> <pre><code>&gt; :info Functor\nclass Functor (f :: * -&gt; *) where\n  fmap :: (a -&gt; b) -&gt; f a -&gt; f b\n  (GHC.Base.&lt;$) :: a -&gt; f b -&gt; f a\n        -- Defined in \u2018GHC.Base\u2019\ninstance Functor Maybe -- Defined in \u2018Data.Maybe\u2019\ninstance Functor (Either a) -- Defined in \u2018Data.Either\u2019\ninstance Functor [] -- Defined in \u2018GHC.Base\u2019\ninstance Functor IO -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((-&gt;) r) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,) a) -- Defined in \u2018GHC.Base\u2019\n</code></pre> <p>Each of those instances are implementations of the Functor class for a  particular higher kinded type. For example, we see <code>[]</code>, which we know is a type  constructor but it is also a higher kinded type, since we can use it like a  \u201cfirst class type\u201d.</p>"},{"location":"Mathematics/cat-higher_kinded_types/#rust","title":"Rust","text":"<p>Rust 1.0 currently lacks support for higher kinded types. This doesn\u2019t mean it  doesn\u2019t have container types or type constructors. It certainly does. It just  hasn\u2019t reified them into a higher kinded type that can be used like a first  class citizen. It is however on the roadmap.</p> <p>Just a note about syntax:</p> <ul> <li><code>trait &lt;-&gt; class</code></li> <li><code>impl &lt;-&gt; instance</code></li> <li><code>enum/struct &lt;-&gt; data</code></li> </ul> <p>However there are interesting resources for working around this:</p> <ul> <li>Using a macro to get HKT!</li> <li>Using iterators instead!</li> </ul>"},{"location":"Mathematics/cat-higher_kinded_types/#other-readings","title":"Other readings","text":"<ul> <li>Lambda Cube</li> <li>2nd-order logic explained</li> <li>Examples of 3rd, 4th \u2026 logic sentences</li> <li>Who first coined the term Higher order Function</li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/","title":"Collected Lambda Calculus Functions","text":""},{"location":"Mathematics/cat-lambda_calculus/#collected-lambda-calculus-functions","title":"Collected Lambda Calculus Functions","text":"<p>The following is a small collection of functions in the untyped lambda calculus which I feel are noteworthy for one reason or another, either by relevance to the foundations of lambda calculus (such as the combinators and natural numbers) or by utility to people who wish to actively make use of this Turing tarpit. Some of them are taken from Wikipedia (which tends to be very reliable on mathematical issues), while others (primarily the list functions) I derived myself.</p> <p>Unless explicitly noted otherwise, natural numbers, booleans, pairs &amp; lists, and all functions for dealing with them use the Church encodings of their values. Operations on other types (e.g., negative or non-integral numbers) are not defined, and if the reader desires them, he must construct such types and the operations on them himself (possibly with the use of pairs acting as typed unions). Additionally, functions for operating on numbers, lists, etc. are only meant for use on those types; if a value of the wrong type is supplied (e.g., if a list is passed to [SUCC]{.L}) or a non-Church encoded value is used, the results are undefined.</p>"},{"location":"Mathematics/cat-lambda_calculus/#common-combinators","title":"Common Combinators","text":"<ul> <li>[K := \u03bbxy. x \u2261 X (X (X X)) \u2261 X\u2032 X\u2032 X\u2032]{.L}</li> <li>[S := \u03bbxyz. (x z) (y z) \u2261 X (X (X (X X))) \u2261 X K \u2261 X\u2032 (X\u2032 X\u2032) \u2261 B (B (B W) C) (B B)]{.L}</li> <li>[I := \u03bbx. x \u2261 S K S \u2261 S K K \u2261 X X]{.L}</li> <li>[X := \u03bbx. x S K]{.L} \u2014 also called [\u03b9]{.L} (iota)</li> <li>[X\u2032 := \u03bbx. x K S K]{.L}</li> <li>[B := \u03bbxyz. x (y z) \u2261 S (K S) K]{.L} \u2014 function composition</li> <li>[C := \u03bbxyz. x z y \u2261 S (S (K (S (K S) K)) S) (K K)]{.L}</li> <li>[W := \u03bbxy. x y y \u2261 S S (K (S K K))]{.L}</li> <li>[Y := \u03bbg. (\u03bbx. g (x x)) (\u03bbx. g (x x)) \u2261 S (K (S I I)) (S (S (K S) K) (K (S I I)))]{.L}</li> <li>[Y\u2032 := (\u03bbxy. x y x) (\u03bbyx. y (x y x)) \u2261 S S K (S (K (S S (S (S S K)))) K)]{.L}</li> <li>[\u0398 := (\u03bbxy. y (x x y)) (\u03bbxy. y (x x y))]{.L} \u2014 called the \"Turing fixed-point combinator\"</li> <li>[\u03c9 := \u03bbx. x x \u2261 S I I]{.L}</li> <li>[\u03a9 := \u03c9 \u03c9]{.L}</li> <li> <p>[\u03a9<sub>2</sub> := (\u03bbx. x x x) (\u03bbx. x x x)]{.L}</p> <p>A fixed point combinator is any function [F]{.L} for which [F g \u2261 g (F g)]{.L} for all [g]{.L}; examples include [Y]{.L}, [Y\u2032]{.L}, and [\u0398]{.L}. Since lambda calculus functions cannot refer to themselves by name, fixed point combinators are needed to implement recursion. For example, the factorial function can be implemented using [f := \u03bbgx. ISZERO x 1 (MULT x (g (PRED x)))]{.L}, which takes a function [g]{.L} and a number [x]{.L}; if [x]{.L} is not zero, it is multiplied by the result of [g (PRED x)]{.L}. Defining [FACTORIAL := Y\u00a0f]{.L} (or [Y\u2032\u00a0f]{.L} or [\u0398\u00a0f]{.L}) means that [FACTORIAL x \u2261 Y f x \u2261 f (Y f) x]{.L}, and so [f]{.L} is able to recurse on itself indefinitely.</p> </li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#natural-numbers","title":"Natural Numbers","text":"<ul> <li>[0 := \u03bbfx. x]{.L}</li> <li>[1 := \u03bbfx. f x]{.L}</li> <li>[2 := \u03bbfx. f (f x)]{.L}</li> <li>[3 := \u03bbfx. f (f (f x))]{.L}</li> <li>[4 := \u03bbfx. f (f (f (f x)))]{.L}</li> <li>[5 := \u03bbfx. f (f (f (f (f x))))]{.L}</li> <li>et cetera</li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#mathematical-operators","title":"Mathematical Operators","text":"<ul> <li> <p>The successor operator (given a natural number [n]{.math}, calculate     [n+1]{.math}):</p> <p>::: L SUCC := \u03bbnfx. f (n f x) ::: -   The predecessor operator (for all [n &gt; 0]{.math}, calculate [n-1]{.math}; for zero, return zero):</p> <p>PRED   :=   \u03bbnfx. n (\u03bbgh. h (g f)) (\u03bbu. x) (\u03bbu. u)          \u2261    \u03bbn. n (\u03bbgk. ISZERO (g 1) k (PLUS (g k) 1)) (\u03bbv. 0) 0          \u2261    \u03bbn. CAR (n (\u03bbx. PAIR (CDR x) (SUCC (CDR x))) (PAIR 0 0))</p> <ul> <li>Addition:</li> </ul> <p>PLUS   :=   \u03bbmnfx. n f (m f x)          \u2261    \u03bbmn. n SUCC m</p> <ul> <li>Subtraction \u2014 [SUB m n]{.L} evaluates to [m - n]{.math} if [m &gt; n]{.math} and to zero otherwise:</li> </ul> <p>::: L SUB := \u03bbmn. n PRED m ::: -   Multiplication:</p> <p>MULT   :=   \u03bbmnf. m (n f)          \u2261    \u03bbmn. m (PLUS n) 0          \u2261    B</p> <ul> <li>Division \u2014 [DIV a b]{.L} evaluates to a pair of two numbers, [a idiv b]{.math} and [a mod b]{.math}:</li> </ul> <p>::: L DIV := Y (\u03bbgqab. LT a b (PAIR q a) (g (SUCC q) (SUB a b) b)) 0 ::: -   Integer division:</p> <p>::: L IDIV := \u03bbab. CAR (DIV a b) ::: -   Modulus:</p> <p>::: L MOD := \u03bbab. CDR (DIV a b) ::: -   Exponentiation ([EXP a b \u2261 a<sup>b</sup>]{.L}):</p> <p>::: L EXP := \u03bbab. b a \u2261 C I ::: -   Factorial:</p> <p>FACTORIAL   :=   Y (\u03bbgx. ISZERO x 1 (MULT x (g (PRED x))))               \u2261    \u03bbn. Y (\u03bbgax. GT x n a (g (MUL a x) (SUCC x))) 1 1               \u2261    \u03bbn. n (\u03bbfax. f (MUL a x) (SUCC x)) K 1 1</p> <ul> <li>Fibonacci numbers \u2014 [FIBONACCI n]{.L} evaluates to the [n]{.L}-th Fibonacci number:</li> </ul> <p>::: L FIBONACCI := \u03bbn. n (\u03bbfab. f b (PLUS a b)) K 0 1 ::: -   Greatest common divisor/highest common factor:</p> <p>::: L GCD := (\u03bbgmn. LEQ m n (g n m) (g m n)) (Y (\u03bbgxy. ISZERO y x (g y (MOD x y)))) :::</p> </li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#booleans","title":"Booleans","text":"<p>Given a boolean value [b]{.L}, the expression [b t f]{.L} will evaluate to [t]{.L} if [b]{.L} is true and to [f]{.L} if [b]{.L} is false. This allows conditional expressions to be written simply as a condition applied directly to the two possible results without the need for an [IF]{.L} function.</p> <ul> <li>[TRUE := \u03bbxy. x \u2261 K]{.L}</li> <li>[FALSE := \u03bbxy. y \u2261 0 \u2261 \u03bbx. I \u2261 K I \u2261 S K \u2261 X (X X)]{.L}</li> <li>[AND := \u03bbpq. p q p]{.L}</li> <li>[OR := \u03bbpq. p p q]{.L}</li> <li>[XOR := \u03bbpq. p (NOT q) q]{.L}</li> <li>[NOT := \u03bbpab. p b a \u2261 \u03bbp. p FALSE TRUE]{.L}</li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#numeric-comparison-operators","title":"Numeric Comparison Operators","text":"<ul> <li> <p>Test whether a number is zero:</p> <p>::: L ISZERO := \u03bbn. n (\u03bbx. FALSE) TRUE ::: -   Less than:</p> <p>::: L LT := \u03bbab. NOT (LEQ b a) ::: -   Less than or equal to:</p> <p>::: L LEQ := \u03bbmn. ISZERO (SUB m n) ::: -   Equal to:</p> <p>::: L EQ := \u03bbmn. AND (LEQ m n) (LEQ n m) ::: -   Not equal to:</p> <p>::: L NEQ := \u03bbab. OR (NOT (LEQ a b)) (NOT (LEQ b a)) ::: -   Greater than or equal to:</p> <p>::: L GEQ := \u03bbab. LEQ b a ::: -   Greater than:</p> <p>::: L GT := \u03bbab. NOT (LEQ a b) :::</p> </li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#pairs-and-lists","title":"Pairs and Lists","text":"<p>Pairs and lists are structured the same way that they are in Lisp and its relatives: a pair is made up of two components, called the car and the cdr, and a list is either [NIL]{.L} (the empty list) or a pair whose cdr is another list (and whose car is an element of the enclosing list).</p> <ul> <li> <p>[PAIR x y]{.L} \u2014 create a pair with a car of [x]{.L} and a cdr of     [y]{.L}; also called [CONS]{.L}:</p> <p>::: L PAIR := \u03bbxyf. f x y ::: -   [CAR p]{.L} \u2014 get the car of pair [p]{.L}; also called [FIRST]{.L} or [HEAD]{.L}:</p> <p>::: L CAR := \u03bbp. p TRUE ::: -   [CDR p]{.L} \u2014 get the cdr of pair [p]{.L}; also called [SECOND]{.L}, [TAIL]{.L}, or [REST]{.L}:</p> <p>::: L CDR := \u03bbp. p FALSE ::: -   The empty list:</p> <p>::: L NIL := \u03bbx. TRUE ::: -   [NULL p]{.L} \u2014 evaluates to [TRUE]{.L} if [p]{.L} is [NIL]{.L} or to [FALSE]{.L} if [p]{.L} is a normal pair (all other types are undefined):</p> <p>::: L NULL := \u03bbp. p (\u03bbxy. FALSE) :::</p> </li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#list-functions","title":"List Functions","text":"<ul> <li> <p>Concatenate two lists:</p> <p>::: L APPEND := Y (\u03bbgab. NULL a b (PAIR (CAR a) (g (CDR a) b))) ::: -   Calculate the length of a list:</p> <p>::: L LENGTH := Y (\u03bbgcx. NULL x c (g (SUCC c) (CDR x))) 0 ::: -   [INDEX x i]{.L} \u2014 evaluates to the [i]{.L}-th (zero-based) element of list [x]{.L}, assuming that [x]{.L} has at least [i+1]{.math} elements:</p> <p>::: L INDEX := \u03bbxi. CAR (i CDR x) ::: -   Get the last element in a list:</p> <p>::: L LAST := Y (\u03bbgx. NULL x NIL (NULL (CDR x) (CAR x) (g (CDR x)))) ::: -   Get a list without its last element:</p> <p>::: L TRUNCATE := Y (\u03bbgx. NULL x NIL (NULL (CDR x) NIL (PAIR (CAR x) (g (CDR x))))) ::: -   Reverse a list:</p> <p>::: L REVERSE := Y (\u03bbgal. NULL l a (g (PAIR (CAR l) a) (CDR l))) NIL ::: -   [RANGE s e]{.L} \u2014 evaluates to a list of all natural numbers from [s]{.L} up through [e]{.L}, or to [NIL]{.L} when [s\u00a0&gt;\u00a0e]{.math}.</p> <p>::: L RANGE := \u03bbse. Y (\u03bbgc. LEQ c e (PAIR c (g (SUCC c) e)) NIL) s ::: -   [LIST n a<sub>0</sub> a<sub>1</sub> ... a<sub>n-1</sub>]{.L} \u2014 evaluates to [a<sub>0</sub> ... a<sub>n-1</sub>]{.L} as a list</p> <p>::: L LIST := \u03bbn. n (\u03bbfax. f (PAIR x a)) REVERSE NIL ::: -   [APPLY f x]{.L} \u2014 passes the elements of the list [x]{.L} to [f]{.L}:</p> <p>::: L APPLY := Y (\u03bbgfx. NULL x f (g (f (CAR x)) (CDR x))) ::: -   [MAP f x]{.L} \u2014 maps each element of the list [x]{.L} through [f]{.L}:</p> <p>::: L MAP := Y (\u03bbgfx. NULL x NIL (PAIR (f (CAR x)) (g f (CDR x)))) ::: -   [FILTER f x]{.L} \u2014 evaluates to a list of all [e]{.L} in the list [x]{.L} for which [f e]{.L} is [TRUE]{.L} (assuming that [f]{.L} returns only [TRUE]{.L} or [FALSE]{.L} for all elements of [x]{.L}):</p> <p>::: L FILTER := Y (\u03bbgfx. NULL x NIL (f (CAR x) (PAIR (CAR x)) I (g f (CDR x)))) ::: -   [CROSS f l m]{.L} \u2014 evaluates to a list of all values of [f a b]{.L} where [a]{.L} is in the list [l]{.L} and [b]{.L} is in the list [m]{.L}. To obtain the Cartesian cross product of [l]{.L} and [m]{.L}, supply [PAIR]{.L} (or a similar function) for [f]{.L}.</p> <p>::: L CROSS := \u03bbflm. FOLD-LEFT APPEND NIL (MAP (\u03bbx. MAP (f x) m) l) ::: -   [FOLD-LEFT f e x]{.L} \u2014 Apply [f a]{.L} to each element of the list [x]{.L}, where [a]{.L} is the result of the previous application (or [e]{.L} for the first application) and return the result of the last application:</p> <p>::: L FOLD-LEFT := Y (\u03bbgfex. NULL x e (g f (f e (CAR x)) (CDR x))) ::: -   [FOLD-RIGHT f e x]{.L} \u2014 Apply [(\u03bby. f y a)]{.L} to each element of the list [x]{.L} in reverse order, where [a]{.L} is the result of the previous application (or [e]{.L} for the first application) and return the result of the last application:</p> <p>::: L FOLD-RIGHT := \u03bbfex. Y (\u03bbgy. NULL y e (f (CAR y) (g (CDR y)))) x :::</p> </li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#other","title":"Other","text":"<ul> <li> <p>[GET n i a<sub>0</sub> a<sub>1</sub> ... a<sub>n-1</sub> =<sup>\u03b2</sup> a<sub>i</sub>]{.L}:</p> <p>::: L GET := \u03bbni. i K (SUB n (SUCC i) K) :::</p> </li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#sources","title":"Sources","text":"<ul> <li>Wikipedia: Lambda     calculus</li> <li>Wikipedia: Combinatory     logic</li> <li>Wikipedia: SKI combinator     calculus</li> <li>Wikipedia: Fixed point     combinator</li> <li>Wikipedia: B,C,K,W     system</li> </ul> <p>Main Page</p> <p>$Id: lambda.html,v 1.3 2014/06/23 01:42:31 jwodder Exp jwodder $ :::</p>"},{"location":"Mathematics/cat-monad/","title":"Monads introduction","text":""},{"location":"Mathematics/cat-monad/#definition","title":"Definition","text":"<p>A monad is an algebraic structure in category theory. In Haskell it is  used to describe computations as sequences of steps, and to handle side effects such as state and IO. When dealing with values with context,  Monad type-class helps us by automatically handling the context for us.</p> <p>A monad consists of three objects, which must satisfy the monad laws.</p>"},{"location":"Mathematics/cat-monad/#whats-the-point-of-monads","title":"What\u2019s the point of monads?","text":"<ol> <li>Supports pure programming with effects.</li> <li>Use of monads is explicit in types.</li> <li>Can generalise functions to any effect.</li> </ol> Type Effect <code>a -&gt; Maybe b</code> Exceptions <code>a -&gt; List b</code> Non-determinism <code>a -&gt; ST b</code> Internal state <code>a -&gt; IO b</code> Input/Output <code>((a -&gt; r) -&gt; r) -&gt; Cont r a</code> Promises"},{"location":"Mathematics/cat-monad/#the-three-basic-objects","title":"The three basic objects","text":"<ul> <li>A type constructor M, such that for any type a, the type      M a is the type of a computation in the monad M that      produces a result of type a.</li> <li>The bind operator (<code>&gt;&gt;=</code>). A function that takes two computations     and performs them one after the other, making the result of the     first computation available to the second.</li> <li>The return function <code>return</code>. A function such that if x::a,     then return x is a computation in M that, when executed     will produce a value of type a.</li> </ul>"},{"location":"Mathematics/cat-monad/#the-monad-type-class","title":"The Monad type class","text":"<pre><code>class Monad m where\nreturn  :: a -&gt; m a\n(&gt;&gt;=)   :: m a -&gt; (a -&gt; m b) -&gt; m b -- bind\n(&gt;&gt;)    :: m a -&gt; m b -&gt; m b        -- then\n-- m &gt;&gt; n = m &gt;&gt;= _ -&gt; n\nfail    :: String -&gt; m a\n</code></pre>"},{"location":"Mathematics/cat-monad/#the-monad-laws","title":"The Monad Laws","text":"<ul> <li>The right unit law: <code>m &gt;&gt;= return</code> equates to <code>m</code></li> <li>The left unit law: <code>return x &gt;&gt;= f</code> equates to <code>f x</code></li> <li>The associativity law: <code>(m &gt;&gt;= f) &gt;&gt;= g</code> equates to      <code>m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g)</code></li> </ul>"},{"location":"Mathematics/cat-monad/#the-functor-laws-covariant-functor-laws","title":"The Functor Laws (covariant functor laws)","text":"<ul> <li>The identity law: must transform the identity in the source      category to the identity in the destination category.</li> <li>The compose law: must transform the composition operator in     the source category to the composition operator in the destination      category.</li> </ul>"},{"location":"Mathematics/cat-monad/#the-applicative-laws-for-functions","title":"The Applicative Laws for functions","text":""},{"location":"Mathematics/cat-monad/#syntax-rules-for-do","title":"Syntax rules for <code>do</code>","text":"<pre><code>do { x }            --&gt; x\ndo { x; &lt;xs&gt; }      --&gt; x &gt;&gt; do { &lt;xs&gt; }\ndo { a &lt;- x; &lt;xs&gt; } --&gt; x &gt;&gt;= a -&gt; do { &lt;xs&gt; }\ndo { let &lt;declarations&gt;; xs }\n--&gt; let &lt;declarations&gt; in do { xs }\n</code></pre>"},{"location":"Mathematics/cat-monad/#implementation-of-return-bind-and-then","title":"Implementation of <code>return</code>, <code>bind</code> and <code>then</code>","text":"<pre><code>return  :: (Monad m) =&gt; a   -&gt; m a\nreturn x = State $ \\s -&gt; (x, s)\n\n(&gt;&gt;=)   :: (Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b\nm &gt;&gt;= k  = State $ \\s -&gt; let (a, s') = runState m s\n                         in runState (k a) s'\n</code></pre>"},{"location":"Mathematics/cat-monad/#functors-and-application","title":"Functors and Application","text":"<p>Functors: Uniform action over a parametrized type, generalizing the map function on lists. A functor transforms one category into another category. Functors arise every time we write compatibility layers and adapters between different pieces of software. In Haskell, the Functor class only encompass  the narrow case where the source and target categories are both categories of ordinary functions</p> <pre><code>class Functor f where\n    fmap :: (a -&gt; b) -&gt; f a -&gt; f b\n    (&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b\n\n-- map id       == id               identity\n-- map (f . g)  == map f . map g    composition\n</code></pre> <p>Applicative: Map function in a context to the value in a context. Can be chained together. All Applicative instances must also be Functor instances.</p> <pre><code>class (Functor f) =&gt; Applicative f where\n    pure :: a -&gt; f a\n    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b\n</code></pre> <p>When one uses a monad transformer it\u2019s possible appreciate that we are using a functor as an adapter layer between two categories: the base monad\u2019s Kleisli category and the transformed monad\u2019s Kleisli category.</p> <p>The functor design pattern embodies a philosophy of programming that emphasizes: - compatibility over standardization - specialization over monolithic frameworks - short-term completion over future-proofing</p>"},{"location":"Mathematics/cat-notes/","title":"Memoization (in terms of set theory)","text":"<ul> <li>A relation is just a subset of pairs</li> <li>These set relations forms a cartesian product</li> <li>So by definition, any subset of the cartesian product is a relation</li> <li>Relations do not have directionality, but functions do</li> <li>A function can therefore be said to be a relation with directional   constraints, namely those going from a domain (lhs) to a codomain (rhs) The   following structure holds for invertible functions</li> </ul> <pre><code>f :: a -&gt; b\ng :: b -&gt; a\ng after f = id\nf after g = id\n</code></pre> <p>This geometric understanding helps intuit a meaning for isomorphisms (and this is for isomorphisms in any given category.)</p>"},{"location":"Mathematics/lang-grammar_relations/","title":"Language: grammar relations","text":""},{"location":"Mathematics/lang-grammar_relations/#taxonomic","title":"Taxonomic","text":"<p>A taxonomic relation describes a hierarchical classification where one term is a subtype or member of another term. For example, \u201canimal\u201d is the taxonomic hypernym of \u201cdog.\u201d The complementary concept, hyponym, is a word whose definition includes another one. These relationships are analogous to <code>inheritance</code> in OOP.</p> \\[X \\subseteq Y\\] Hypernym Co-hyponyms color red, green, blue celestial object sun, moon, star adjective brigh, loud, red"},{"location":"Mathematics/lang-grammar_relations/#dependency","title":"Dependency","text":"<p>A dependency relation shows how one concept depends on another for its definition. The object is defined in part by its components. These relationships are analogous to <code>composition</code> in OOP.</p> \\[X \\supseteq \\{p_1, p_2, \\ldots \\}\\] <p>A sphere (hyponym) is an \u201corientable surface\u201d (hypernym). A sphere (holonym) has a surface and an inside (meronyms).</p>"},{"location":"Mathematics/lang-grammar_relations/#associative","title":"Associative","text":"<p>An associative relation exists between two words \\(x\\) and \\(y\\) when there is a context \\(C\\) that provides a meaningful connection between them.</p> \\[\\begin{aligned} g:(x,y) &amp;\\rightarrow C\\\\ g:(\\text{doctor}, \\text{hospital}) &amp;\\rightarrow \\text{ healthcare} \\end{aligned}\\] <p>All co-meronyms and co-hyponyms also exhibit an associative relationship. Its common context is given by its hypernym or holonym. However, the presence of an associative relationship between two words does not necessarily imply a taxonomic or dependent relationship. For example it can be argued that \\(g: (\\text{family}, \\text{house}) \\rightarrow C\\). Yet each word has its own definition that doesn\u2019t depend on the shared context \\(C\\).</p>"},{"location":"Mathematics/lang-grammar_relations/#converseness-relational-opposites","title":"Converseness (relational opposites)","text":"<p>Converseness occurs when two words describe the same relationship from opposite perspectives. In other words, each word represents a different role in the same situation or interaction.</p> \\[\\begin{aligned}     \\text{Linguistic Term 'converse'} &amp;\\cong \\text{Mathematical Operator } \\leftrightarrow \\\\     P(x) &amp;\\leftrightarrow Q(y) \\text{ represents a converse relationship} \\\\     \\text{child}(x)   &amp;\\leftrightarrow \\text{parent}(y)   \\text{ where } x \\text{ is a child of } y \\\\     \\text{Hyponym}(x) &amp;\\leftrightarrow \\text{Hypernym}(y) \\text{ where } x \\text{ is an instance of } y \\\\     \\text{Meronym}(x) &amp;\\leftrightarrow \\text{Holonym}(y)  \\text{ where } x \\text{ is a part of } y \\\\ \\end{aligned}\\] <p>Using modal logic:</p> \\[\\begin{aligned}     \\text{Child} &amp;\\rightarrow \\Box\\text{Parent} \\\\     \\text{Hyponym} &amp;\\rightarrow \\Box\\text{Hypernym} \\end{aligned}\\]"},{"location":"Mathematics/lang-grammar_relations/#functional","title":"Functional","text":"<p>Connections between two concepts where one concept invokes or expects the existence of the other. They are directional and dependent. Consider the following examples:</p> \\[f: X \\rightarrow \\{Y, \\emptyset \\}\\] <ul> <li> <p>A question seeks an answer. However, not al questions have valid or clear answers without context. \\(f(question) = answer\\), where \\(f\\) is a partial function that may return a valid answer if the context allows.</p> </li> <li> <p>A cause brings about an effect. Some causes may have predictable effects, while others might have multiple or unforeseen outcomes.</p> </li> <li> <p>A lock functionally requires a key to perform its role (locking/unlocking).</p> </li> </ul> \\[\\begin{aligned}     \\text{Request}(x) &amp;\\rightarrow \\diamond\\text{Fulfillment}(y) \\\\     \\text{Stimulus}(x) &amp;\\rightarrow \\diamond\\text{Response}(y) \\\\     \\text{Question}(x) &amp;\\rightarrow \\diamond\\text{Answer}(y) \\\\ \\end{aligned}\\]"},{"location":"Mathematics/lang-grammar_relations/#notes","title":"NOTES","text":"<ul> <li>Homonymy (equal) is co-hyponym of paronymy (similar).</li> <li>Antonymy (opposite) is the antonym of synonymy (equivalent)</li> </ul>"},{"location":"Science/bio-basic_fungi/","title":"Lo b\u00e1sico del fungi","text":"<p>La herbolaria no es una farmacologia sin m\u00e9todo, es una practica.</p>"},{"location":"Science/bio-basic_fungi/#tipos-de-hongos","title":"Tipos de Hongos","text":"<ul> <li>patogenos y parasitarios</li> <li>comestibles</li> <li>psicoactivos</li> <li>entomopatogenos (bioinsecticidas)</li> <li>liquenes (asociacion hongos, algas y bacterias)     indicadores de la calidad de aire</li> <li>miscelio (biomateriales)</li> <li>levaduras (edicion genetica y escalamiento industrial, eucariotas)</li> </ul>"},{"location":"Web3/icp-concepts/","title":"ICP Concepts","text":""},{"location":"Web3/icp-concepts/#flow-of-a-message-on-icp","title":"Flow of a message on ICP","text":"<ol> <li>The <code>message</code> goes to one of the <code>boundary nodes</code> (RPC nodes)</li> <li>The <code>boundary node</code> routes the message to the <code>subnet</code> that    hosts the target <code>smart contract</code></li> <li>The <code>consensus algorithm</code> of that <code>subnet</code> adds the message to    a new <code>block</code> in the <code>subnet</code>\u2019s blockchain</li> <li>The <code>message</code> is added to the input queue of the target <code>smart    contract</code></li> <li>The <code>smart contract</code> executes the <code>message</code></li> </ol> <ul> <li>Each ICP <code>subnet</code> has a fixed <code>public key</code></li> <li>I CP actively gargbage collects old <code>blocks</code></li> <li>ICP runs <code>smart contracts</code> in parallel (like microservices)</li> <li><code>smart contracts</code> can have their own <code>secret keys</code></li> <li></li> </ul>"},{"location":"Web3/web3-common_terms/","title":"Common terms","text":"<ul> <li> <p>CAP theorem: A principle stating that in distributed systems, only two of the following three properties are achievable at the same time:</p> <ul> <li>Consistency: all nodes have the same data</li> <li>Availability: system is responsive</li> <li>Partition Tolerance: system continues operating despite network partitions</li> </ul> </li> <li> <p>Consensus algorithm: A protocol used by distributed systems to achieve agreement among nodes on the state of the <code>ledger</code>, even in the presence of faulty or malicious actors.</p> </li> <li> <p>Fault tolerant replicated machine: A system where multiple nodes replicate the same state and continue functioning correctly even if some nodes fail or act maliciously.</p> </li> <li> <p>Finality: The assurance that once a transaction is added to the blockchain, it cannot be altered or reversed (transaction permanence).</p> </li> <li> <p>Fork: A divergence in the blockchain\u2019s protocol or ledger. It can be soft (backward-compatible) or hard (creating two separate chains).</p> </li> <li> <p>Horizontal scaling: The process of adding more nodes to a distributed system to increase its capacity and performance, rather than upgrading the hardware of existing nodes.</p> </li> <li> <p>Ledger: A distributed and immutable record of transactions shared across a network of nodes in a blockchain. It ensures transparency, traceability and trust.</p> </li> <li> <p>Sharding: A method for improving scalability in blockchains by partitioning the network\u2019s <code>state</code> and transactions into smaller, manageables pieces (shards). This allows the system to process many transactions in parallel.</p> </li> </ul> Abstract Term In Cloud Computing In Blockchain Stateless Function Lambda Functions Smart contracts Horizontal Scaling Adding more servers/nodes Adding more nodes (validators/miners) Consensus Leader election, Paxos/Raft PoW, PoS, BFT, PoA NoSQL Databases DynamoDB, MongoDB Distributed ledgers (e.g., Ethereum) Virtual Machines EC2, Kubernetes pods EVM (Ethereum), WASM (Polkadot) Transaction Logs Database write-ahead logs Blockchain ledger Load Balancing Traffic distribution (ELB) Transaction propagation across nodes Data Sharding Database partitioning Blockchain state sharding Fault Tolerance Redundant infrastructure Byzantine Fault Tolerance (BFT) Authentication IAM, OAuth Public/private keys, cryptography State Management Session/Cache databases Account balances, Contract state) Immutable Data Write-once storage (S3) Immutable transaction history Snapshot Database snapshots Blockchain checkpoints"},{"location":"Web3/web3-common_terms/#smart-contracts-development","title":"Smart Contracts Development","text":"<pre><code>graph TD\n  dev[\"Smart Contracts Development\"]\n  dev --&gt; framework[\"Dev Framework\"];\n  dev --&gt; runtime[\"Runtime Model\"];\n  dev --&gt; cpi[\"Cross-Program Invocations\"];\n  dev --&gt; security[\"Security Auditing\"];\n  dev --&gt; optimization[\"Performance Optimization\"];\n  dev --&gt; frontend[\"Frontend Integration\"];\n\n  dev --&gt; Applications;\n\n  runtime --&gt; optimization;\n  runtime --&gt; security;\n  runtime --&gt; cpi;\n\n  framework --&gt; cpi;\n  framework --&gt; security;\n\n  cpi --&gt; security;\n\n  optimization --&gt; defi;\n  optimization --&gt; nft;\n\n  tokens --&gt; defi;\n  tokens --&gt; nft;\n\n  defi --&gt; frontend;\n  nft --&gt; frontend;\n\n  frontend --&gt; sdk[\"CLI &amp; SDK\"];\n  sdk --&gt; dev;\n\n  subgraph Tools\n    framework\n    frontend\n    sdk\n  end\n\n  subgraph Applications\n    defi[\"DeFi\"]\n    nft[\"NFT\"]\n    tokens[\"Tokenomics\"]\n  end</code></pre>"},{"location":"Web3/web3-proof_of_x/","title":"Proof of X","text":"<p>The term refers to a consensus mechanism or validation method in a distributed system that establishes trust, agreement and prevents malicious behavior without relying on a central authority. It ensures that only valid transactions are added to the blockchain, while discouraging attacks. It consistes of:</p> <ol> <li>A set of participants \\(P\\) (nodes, validators, miners)</li> <li>A condition \\(C_X\\) that must be satisfied for validation</li> <li>A validation function \\(V(p)\\) for verifying that a \\(p \\in P\\)    satisfies \\(C_X\\)</li> </ol> <p>Thus, the essence of any \\(\\text{Proof of } X\\) mechanism boils down to:</p> \\[M_X := V(p) = \\left\\{ \\begin{array}{ll}     1 &amp;\\text{if } p \\text{ satisfies } C_X,\\\\     0 &amp;\\text{otherwise} \\end{array}\\right.\\]"},{"location":"Web3/web3-proof_of_x/#proof-of-work","title":"Proof of Work","text":"<p>Its condition \\(C\\) is tied to computation effort. The participants must find a nonce \\(n\\) such that the hash of the block and nonce is less than a certain target value \\(T\\). This process ensures the difficulty of mining new blocks, requiring energy expenditure to secure the network. Its used by <code>Bitcoin</code>.</p> \\[C_\\text{PoW}: H(\\text{block}, n) &lt; T\\]"},{"location":"Web3/web3-proof_of_x/#proof-of-stake","title":"Proof of Stake","text":"<p>Its condition \\(C\\) is based on ownership of stake in the network. To being eligible to be selected as a validator, participants must own a stake \\(S_p\\) that is higher than some threshold \\(S_\\text{min}\\). By tying validation rights to economic stake, <code>PoS</code> incentivizes good behavior by imposing potential financial losses for dishonest actions. Different versions of this mechanism are implemented by <code>Cardano</code>, <code>Ethereum 2.0</code> and <code>Polkadot</code>.</p> \\[C_\\text{PoS}: S_p &gt; S_\\text{min}\\]"},{"location":"Web3/web3-proof_of_x/#proof-of-history","title":"Proof of History","text":"<p>Its condition \\(C\\) is based on the participant\u2019s ability to cryptographically prove that certain evets happened in a specific sequence in time. In order to do this, the participant must generate a verifiable cryptographic sequence \\(S\\) where each element of the sequence depends on the previous element. It provides a cryptographic clock for the network, enabling efficient consensus in combination with <code>PoS</code>. <code>Solana</code> implements this model.</p> \\[C_\\text{PoH}: S = \\{ s_1, s_2, s_3, \\ldots, s_n \\} \\text{ where } s_{i+1}=H(s_i)\\]"},{"location":"Web3/web3_comparative/","title":"Blockchains comparative","text":""},{"location":"Web3/web3_comparative/#bitcoinstacks","title":"Bitcoin/STACKS","text":""},{"location":"Web3/web3_comparative/#ethereum","title":"Ethereum","text":"<ol> <li>Toolchains</li> <li>Create a wallet</li> <li>Get testnet tokens (faucet)</li> <li>Set up and run a node</li> <li>Deploy a smart contract</li> <li>Interact with a smart contract</li> <li>Query blockchain data</li> <li>Inspect network statistics</li> <li>Validate and sign transactions</li> <li>Staking or validator operations</li> </ol>"},{"location":"Web3/web3_comparative/#icp-internet-computer-protocol","title":"ICP (Internet Computer Protocol)","text":""},{"location":"Web3/web3_comparative/#polkadotastar","title":"Polkadot/Astar","text":""},{"location":"Web3/web3_comparative/#solana","title":"Solana","text":"<ol> <li>Toolchains</li> </ol> <pre><code># solana-cli\nsh -c \"$(curl -sSfL https://release.anza.xyz/stable/install)\"\nagave-install update\n\n# anchor framework\ncargo install --git https://github.com/coral-xyz/anchor avm --force\navm install latest\navm use latest\n</code></pre> <ol> <li>Create a wallet: Solflare</li> </ol> <pre><code>solana config set --keypair ~/.config/solana/solflare:private_key.json\nsolana address\n</code></pre> <ol> <li>Get testnet tokens (faucet): Solana faucet</li> <li>Set up and run a node</li> <li>Deploy a smart contract</li> <li>Interact with a smart contract</li> <li>Query blockchain data</li> <li>Inspect network statistics: Solana Explorer</li> <li>Validate and sign transactions</li> <li>Staking or validator operations</li> <li>Developer Learning resources:<ul> <li>Github: solana-awesome</li> <li>Course: Ethereum to Solana developer</li> <li>Course: Advanced Solana developer</li> <li>Docs: Solana CookBook</li> </ul> </li> </ol>"}]}