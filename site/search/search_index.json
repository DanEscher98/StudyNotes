{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Paraefatio","text":"<p>Hi there</p>"},{"location":"Computing/algo-bigO_notation/","title":"Big O Notation","text":"<ul> <li>In \\(f(n) = O(g(n))\\), \\(f(n)\\) grows as most as quickly as \\(g(n)\\)</li> <li>In \\(f(n) = \\Omega(g(n))\\), \\(f(n)\\) grows at least as quickly as     \\(g(n)\\)</li> <li>If \\(f(n) = O(g(n))\\) and \\(f(n) = \\Omega(g(n))\\) then \\(f(n) =     \\Theta(g(n))\\)</li> </ul>"},{"location":"Computing/algo-fibonacci_heaps/","title":"Binary Heaps","text":""},{"location":"Computing/algo-fibonacci_heaps/#rules","title":"Rules","text":"<ol> <li>Every level is full, last one from left to right</li> <li>Heap property: No child is smaller than its parent</li> </ol>"},{"location":"Computing/algo-fibonacci_heaps/#properties","title":"Properties","text":"<ul> <li><code>GetMin</code> \\(O(1)\\): Just lookup the value of the root node, which by     rule 2 has also the minimum value.</li> <li><code>Insert</code> \\(O(\\log{n})\\): By rule 1 there\u2019s only one valid position.     If it violates rule 2, the fix is bubbling up the node until     its fixed.</li> <li><code>ExtractMin</code> \\(O(\\log{n})\\): Just removing the <code>root node</code> creates a     gap.<ol> <li>swap its value with right-most value of the last level.</li> <li>remove the <code>leaf</code>, with the former value of the <code>root node</code></li> <li>swap the <code>root node</code> value with the lowest of its <code>children    nodes</code> until rule 2 is satisfied.</li> </ol> </li> <li><code>DecreaseKey</code> \\(O(\\log{n})\\): This is useful to change priorities.<ol> <li>find the desired <code>node</code> and change its value</li> <li>fix rule 2 by bubbling the value</li> </ol> </li> </ul>"},{"location":"Computing/algo-fibonacci_heaps/#references","title":"References","text":"<ul> <li> Fibonacci Heaps - SithDev</li> </ul>"},{"location":"Computing/cpp-basic_pointers/","title":"Pointers in C","text":""},{"location":"Computing/cpp-basic_pointers/#types-of-pointers","title":"Types of pointers","text":"<ul> <li><code>Null Pointer</code>: It\u2019s a pointer that points to nothing. They are useful     at initialization.</li> <li><code>Void Pointer</code>: It\u2019s a pointer that is not allied with any data types.     Points to some data location within the storage. It\u2019s also known     as a general purpose pointer. In C, <code>malloc</code> and <code>calloc</code>     functions return <code>void*</code>.</li> <li><code>Wild Pointer</code>: Pointers that are not initialized. It could be     initialized to a non-NULL garbage value which may not be a valid     address.</li> <li><code>Dangling Pointer</code>: A pointer that points to a memory location that     has been deleted.</li> <li><code>Struct Pointer</code>: This pointers can be utilized to refer to a struct     by its address. This helps pass structs to a function.</li> <li><code>Near Pointer</code>: It means a pointer that is utilized to bit address of     up to 16 bits within a given section of that computer memory which     is 16 bit enabled. It can only access data of the small size of     about 64kb withing a given period, which is its main disadvantage.</li> <li><code>Far Pointer</code>: Is typically 32 bit which can access memory outside     that current segment. To utilize the far pointer, the compiler     allows a segment register to save segment address, then another     register to save offset inside current segment.</li> <li><code>Huge Pointer</code>: A far pointer that is fixed and hence that part of     that sector within which they are located cannot be changed in any     way; huge pointers can be.</li> </ul> <pre><code>flowchart LR  \n    A(variable) --&gt;|&amp;| B(pointer)\n    B --&gt;|*| A</code></pre> <pre><code>// Declare a reference\nint&amp; num;\n// Equivalent accessing\n*(ptr + n) = val;\nptr[n] = val;\n// Equivalent accessing\n*(*(ch_arr + i) + j);\nch_arr[i][j];\n// Equivalent for structs\n(*node).next;\nnode-&gt;next;\n</code></pre>"},{"location":"Computing/cpp-basic_pointers/#references","title":"References","text":"<ul> <li> How to interpret complex <code>C/C++</code> (pointer) declarations</li> </ul>"},{"location":"Computing/hs-monadic_operators/","title":"Haskell's basic Operators","text":""},{"location":"Computing/hs-monadic_operators/#mathematics-and-lists","title":"Mathematics and Lists","text":"<ul> <li>Arithmetic: <code>+ * - / ^ ^^ **</code></li> <li>Logical: <code>&amp;&amp; || == /= &lt; &lt;= &gt;= &gt;</code></li> <li>Lists: <code>: ++ !!</code></li> </ul>"},{"location":"Computing/hs-monadic_operators/#functions-and-controlmonad","title":"Functions and Control.Monad","text":"<ul> <li><code>(.)</code> = Function composition</li> <li><code>($)</code> = Operator with right associativity and has the lowest precedence</li> <li><code>($!)</code> = The same as <code>($)</code> but also force strict evaluation</li> <li><code>(&gt;&gt;)</code> = Operator <code>then</code>, chains two monadic expressions</li> <li><code>(&gt;&gt;=)</code> = Operator <code>bind</code>, makes available the result of the previous     computation to the next expression</li> <li><code>(=&lt;&lt;)</code> = The same as operator <code>bind</code>, but with right associativity</li> <li><code>(&lt;$&gt;)</code> = Functor; this operator wraps the value. The infix of <code>fmap</code></li> <li><code>(&lt;*&gt;)</code> = Applicative; this also wraps the function</li> </ul>"},{"location":"Computing/hs-monadic_operators/#in-controlmonad","title":"In Control.Monad","text":"<ul> <li><code>(&lt;=&lt;)</code> = Allows do compositions of monadic computations</li> <li><code>(&gt;=&gt;)</code> = The same as <code>(&lt;=&lt;)</code> but with left associativity</li> </ul>"},{"location":"Computing/hs-monadic_operators/#in-datafunction","title":"In Data.Function","text":"<ul> <li><code>(&lt;$)</code> = </li> <li><code>($&gt;)</code> = </li> </ul>"},{"location":"Computing/hs-syntactic_sugar/","title":"Syntactic Sugar in Haskell","text":""},{"location":"Computing/hs-syntactic_sugar/#miscellaneous","title":"Miscellaneous","text":"Syntactic Evaluation <code>(+x)</code> <code>flip (+) x</code>"},{"location":"Computing/hs-syntactic_sugar/#lists","title":"Lists","text":"Syntactic Evaluation <code>[a]</code> <code>Lista a</code> <code>[0..2]</code> <code>[0,1,2]</code> <code>[1,2,3]</code> <code>1:2:3:[]</code> <code>[f e | e &lt;- xs]</code> <code>map f xs</code>"},{"location":"Computing/hs-syntactic_sugar/#guards","title":"Guards","text":"<p>The expression</p> <pre><code>funk x\n| even x    = 1\n| otherwise = 0\n</code></pre> <p>is evaluated as:</p> <pre><code>funk x = if even x\nthen 1\nelse 0\n</code></pre>"},{"location":"Computing/hs-syntactic_sugar/#do-notation","title":"Do notation","text":"<pre><code>main = do\ns &lt;- getStr\nputStr s\nputStr \"Hi\"\n</code></pre> <p>is evaluated as:</p> <pre><code>main = getStr &gt;&gt;=\n(\\s -&gt; putStr s &gt;&gt; (putStr \"Hi\"))\n</code></pre>"},{"location":"Computing/hs-thoughts_monads/","title":"Thoughs about Monads","text":""},{"location":"Computing/hs-thoughts_monads/#applications-of-monads","title":"Applications of Monads","text":"<ul> <li>For Haskell so loved the <code>world -&gt; (a, world)</code> that it gave us the     <code>IO Monad</code>, that whosoever composes with it should not be impure,     but free of side effects.</li> <li>They have three properties that make them useful:<ol> <li>Modularity: They allow computations to be composed from simpler    computations and separate the combination strategy from the    actual computations being performed.</li> <li>Flexibility: They allow functional programs to be much more    adaptable than equivalent programs written without monads. This    is because the monad distills the computational strategy into a    single place instead of requiring it be distributed throughout    the entire program.</li> <li>Isolation: They can be used to create imperative-style    computational structures which remain safely isolated from the    main body of the functional program. This is useful for    incorporating side-effects which remain safely isolated from    the main body of the functional program. This is useful for    incorporating side-effects and state into a pure functional    language.</li> </ol> </li> <li>Mathematically all monads are functors.</li> <li>Monads are programmable semicolons.</li> <li>Monads are like burritos. A functor <code>F</code> takes each type <code>T</code> and     maps it to a new type <code>F(T)</code>. A burrito takes a type, meat or     beans, and turns it into a new type, like beef burrito.<ul> <li>functor: burrito</li> <li>map: you can add onion to beans, so also to a bean burrito</li> <li>pure: the tortilla which lifts any type to a burrito.</li> <li>join: if I had burrito burrito, I can unwrap the inner burrito</li> </ul> </li> <li>Think of monads as statically typed filters in the Unix sense of     \u201cpipes and filters\u201d.</li> <li>In Haskell, <code>main</code> is <code>main :: IO ()</code> or <code>main :: () -&gt; IO ()</code>. So, a     Haskell program is just one big Kleisli arrow in the <code>IO</code> monad.</li> <li>In game programming, when a computer plays against a human, it can\u2019t     predict the opponent\u2019s next move. It can, however, generate a list     of all possible moves and analyze them one by one.</li> <li>A function that has has read-only access to some external state, or      environment, can be always replaced by a function that takes that     environment as an additional argument <code>(a, e) -&gt; b</code>.</li> <li>When is called, The function <code>getChar :: () -&gt; IO Char</code> returns a      character inside a container, and each time it would return exactly     the same container. Conceptually, this container would contain the     superposition of all possible characters. It\u2019s possible compose     <code>getChar</code> with another Kleisli arrow, but this second arrow could     only return his value as an <code>IO a</code> (a supperposition of all possible     <code>a</code> values). There is no <code>runIO</code>.</li> <li>If the program is purely functional, we can mathematically combine     smaller programs to make complex ones and reason about the     soundness and correctness of a program.</li> <li>A Monad is a new type that the language knows how to treat when     composing functions. They can encapsulate side effects or just     purely functional computations and making function composition     possible.</li> <li>Generally, Category Theory helps Computer Science by discovering     \u201ccomputational patterns\u201d. Category Theory discovers them and studies     them in order to find their mathematical properties. Then, Computer     Science can make use of this knowledge in order to empower     developers to create software in a more concise and more correct     way.</li> <li><code>Type ~&gt; Functor ~&gt; Applicative Functor ~&gt; Monad</code><ul> <li><code>fmap :: (a -&gt; b) -&gt; F a -&gt; F b</code> lifts a function. If you will     gave me a blueberry for each apple I gave you <code>(a -&gt; b)</code> ,     and I have a box of apples <code>(F a)</code> , then I can get a box of     blueberries <code>(F b)</code>.</li> <li><code>pure :: a -&gt; M a</code> lifts a type to the M realm, it\u2019s a NT.     If I have an apple <code>(a)</code> then I can put it in a box <code>(M a)</code>.</li> <li><code>(&lt;*&gt;) :: M (a -&gt; b) -&gt; M a -&gt; M b</code> applies a function</li> <li><code>join :: M (M a) -&gt; M a</code> If I have a box of apples <code>M (M a)</code> then I can take the apples from each, and put them in a new     box <code>(M a)</code>.</li> <li><code>(&gt;&gt;=) :: M a -&gt; (a -&gt; M b) -&gt; M b</code> provides a way to compose     functions. It\u2019s a Natural Transformation (NT). If I have a      box of apples <code>(M a)</code> and for each apple you will give me a     box of blueberries <code>(a -&gt; M b)</code> then I can get a box with     all the blueberries together <code>(M b)</code>.     <pre><code>xs &gt;&gt;= f = join (fmap f xs)\n</code></pre></li> </ul> </li> </ul>"},{"location":"Computing/hs-thoughts_monads/#code-examples","title":"Code Examples","text":""},{"location":"Computing/hs-thoughts_monads/#list-monad","title":"List Monad","text":"<pre><code>instance Monad [] where\njoin     = concat\nreturn x = [x]\nas &gt;&gt;= k = concat (fmap k as)\nliftM :: (Monad m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b\nliftM f xs = xs &gt;&gt;= (return . f)\nliftM f xs = do x &lt;- xs\nreturn (f x)\n</code></pre> <pre><code>instance Monad Maybe where\nNothing &gt;&gt;= k = Nothing\nJust a  &gt;&gt;= k = k a\nreturn a      = Just a\n</code></pre>"},{"location":"Computing/hs-thoughts_monads/#state-monad","title":"State Monad","text":"<pre><code>newtype State s a = State (s -&gt; (a, s))\nrunState :: State s a -&gt; s -&gt; (a, s)\nget :: State s s\nput :: s -&gt; State s ()\ninstance Monad (State s) where\nsa &gt;&gt;= k = State (\\s -&gt; let (a, s') = runState sa s\nin runState (k a) s')\nreturn a = State (\\s -&gt; (a, s))\n</code></pre>"},{"location":"Computing/hs-thoughts_monads/#reader-monad","title":"Reader Monad","text":"<pre><code>newtype Reader e a = Reader (e -&gt; a)\ninstance Monad (Reader e) where\nra &gt;&gt;= k = Reader (\\e -&gt; runReader (k (runReader ra e)) e)\nreturn x = Reader (\\e -&gt; x)\nrunReader :: Reader e a -&gt; e -&gt; a\nrunReader (Reader f) e = f e\n</code></pre>"},{"location":"Computing/hs-thoughts_monads/#continuations-dont-call-us-well-call-you","title":"Continuations Don\u2019t call us, we\u2019ll call you!","text":"<pre><code>data Cont r a = Cont ((a -&gt; r) -&gt; r)\nrunCont :: Cont r a -&gt; (a -&gt; r) -&gt; r\nrunCont (Cont k) h = k h\n-- Our goal is create a function that takes\n-- the handler `(b -&gt; r)` and produces the result `r`.\n-- (&gt;&gt;=) :: ((a -&gt; r) -&gt; r) -&gt;\n--          (a -&gt; (b -&gt; r) -&gt; r) -&gt;\n--          ((b -&gt; r) -&gt; r)\ninstance Monad (Cont r) where\nka &gt;&gt;= kab = Cont (\\hb -&gt; runCont ka (\\a -&gt; runCont (kab a) hb))\nreturn a = Cont (\\ha -&gt; ha a)\n</code></pre>"},{"location":"Computing/hs-thoughts_monads/#references","title":"REFERENCES","text":"<ul> <li>A monad is just a \u2026</li> <li>The correspondence between Monads in CT and Haskell</li> <li>Monads as containers</li> <li>Monads as computations</li> </ul>"},{"location":"Computing/lowlv-memory/","title":"Understanding memory","text":""},{"location":"Computing/lowlv-memory/#kinds-of-memory-and-its-applications","title":"Kinds of memory and its applications:","text":"<p>Each byte in the memory is addressable</p> <ul> <li><code>Global/static</code>:<ul> <li>Static memory persists throughout the entire life of the program</li> <li>Is usually used to store things like global variables</li> <li>Or variables created with the static clause</li> </ul> </li> <li><code>Stack</code>:<ul> <li>the stack is managed by the CPU</li> <li>It\u2019s a LIFO structure. Every time a function declares a new     variable, it\u2019s \u201cpushed\u201d onto the stack</li> <li>variables are allocated and freed automatically</li> <li>the stack it not limitless \u2013 most have an upper bound</li> <li>the stack grows and shrinks as variables are created and     destroyed</li> <li>stack variables only exist whilst the function that created     them exists</li> </ul> </li> <li><code>Heap</code>:<ul> <li>the heap is managed by the programmer, and is the portion of     memory where dynamically allocated memory resides</li> <li>in <code>C</code>, variables are allocated and freed using functions like     <code>malloc()</code> and <code>free()</code></li> <li>the heap is large, and is usually limited by the physical memory     available</li> <li>the heap requires pointers to access it</li> <li>If all references to allocated memory are lost (e.g. you don\u2019t     store a pointer to it anymore), you have what is called a     memory leak.</li> <li>Unlike the stack where memory is allocated and released in a     very defined order, individual data elements allocated on the     heap are typically released in ways which is asynchronous     from one another.</li> </ul> </li> </ul>"},{"location":"Computing/lowlv-multiprocessing/","title":"Multi Process","text":""},{"location":"Computing/lowlv-multiprocessing/#features-of-threading","title":"Features of Threading","text":""},{"location":"Computing/lowlv-multiprocessing/#benefits-of-threading","title":"Benefits of threading:","text":"<ul> <li>Ease of reading code. The code can run concurrently, but still be     set out in a very simple, top-down linear sequence commands.</li> <li>Parallelism with shared memory. The code can exploit multiple CPUs     while having threads share memory. This is important in many     workloads where it would be too costly to move large amounts of     data between the separate memory spaces of different processes.</li> <li>Know-how and existing code.</li> </ul>"},{"location":"Computing/lowlv-multiprocessing/#drawback-of-threading","title":"Drawback of Threading","text":"<ul> <li>Threading is difficult. Threading bugs and race conditions in     threaded programs are the hardest kind of bugs to fix.</li> <li>Threads are resource-intensive. Threads require extra operating     system resources to create, such as preallocated, per-thread stack     space that consumes process virtual memory up front.</li> <li>Threading can affect throughput. At very high concurrency levels     (i.e &gt;5,000 threads), there can also be an impact on throughput     due to context-switching costs, assuming you can figure out how     to configure your operating system to even allow you to create     that many threads.</li> <li>Threading is inflexible. The operating system share CPU time with     all threads regardless of whether a thread is ready to do work or     not.</li> </ul>"},{"location":"Computing/lowlv-multiprocessing/#features-of-asyncio","title":"Features of <code>Asyncio</code>","text":"<p>For I/O-bound workloads, there are two reasons to use async-bases concurrency over thread-based concurrency:</p> <ul> <li>Asyncio offers a safer alternative to preemptive     multitasking (i.e., using threads) thereby avoiding the bugs, race     conditions, and other nondeterministic dangers that frequently     occur in nontrivial threaded applications.</li> <li>Asycio offers a simple way to support many thousands osf     simultaneous socket connections, including being able to handle     many long-lived connections for newer technologies like     WebSockets, or MQTT for Internet of Things applications.</li> </ul> <p>Threading, as a programming model, is best suited to certain kinds of computational tasks that are best executed with multiple CPUs and shared memory for efficient communication between the threads. The true value of threading lies in being able to write multi-CPU programs, in which different computational tasks can share memory.</p> <p>Asyncio provides another tool for concurrent programming in Python, that is more lightweight than threads or multiprocessing. In a very simple sens it does this by having an event loop execute a collection of tasks, with a key difference being that each task chooses when to yield control back to the event loop.   \u2013 Philip Jones, \u201cUnderstanding Asyncio\u201d</p> <p>The main features that end users should care about are a small subset of the whole asyncio API: - Starting the asyncio event loop - Calling <code>async/await</code> functions - Creating a task to be run on the loop - Waiting for multiple tasks to complete - Closing the loop after all concurrent tasks have completed</p>"},{"location":"Computing/lowlv-multiprocessing/#things-that-asyncio-is-not","title":"Things that Asyncio is not","text":"<ul> <li>Asyncio doesn\u2019t make a code blazing fast</li> <li>Asyncio doesn\u2019t makes threading redundant</li> <li>Asyncio doesn\u2019t removes the problems with the Global Interpreter     Lock (<code>GIL</code>).</li> <li>Asyncio doesn\u2019t prevents all race conditions</li> <li>Asyncio doesn\u2019t make concurrent programming easy. It only makes a     little easyer to avoid certain race condition bugs</li> </ul>"},{"location":"Computing/rust-keywords/","title":"Rust Keywords","text":""},{"location":"Computing/rust-keywords/#conditional-and-loop-structures","title":"Conditional and Loop Structures","text":"<ul> <li>break exit a loop immediately</li> <li>continue continue to the next loop iteration</li> <li>for loop over items from an iterator, implement a trait,     or specify a higher-ranked lifetime</li> <li>in part of for loop syntax</li> <li>loop loop unconditionally</li> <li>while loop conditionally based on the result of an expression</li> <li>if branch based on the result of a conditional expression</li> <li>else fallback for if and if let control flow constructs</li> <li>match match a value to patterns</li> <li>false Boolean false literal</li> <li>true Boolean true literal</li> </ul>"},{"location":"Computing/rust-keywords/#functions-and-variables","title":"Functions and Variables","text":"<ul> <li>fn define a function or the function pointer type</li> <li>return return from function</li> <li>const define constant items or constant raw pointers</li> <li>let bind a variable</li> <li>move make a closure take ownership of all its captures</li> <li>mut denote mutability in references, raw pointers, or     pattern bindings</li> <li>pub denote public visibility in struct fields, impl     blocks, or modules</li> <li>ref bind by reference</li> <li>static global variable or lifetime lasting the entire program     execution</li> </ul>"},{"location":"Computing/rust-keywords/#data-structures-functions-and-variables","title":"Data Structures, Functions and Variables","text":"<ul> <li>enum define an enumeration</li> <li>impl implement inherent or trait functionality</li> <li>Self a type alias for the type implementing a trait</li> <li>self method subject or current module</li> <li>struct define a structure</li> <li>super parent module of the current module</li> <li>trait define a trait</li> <li>type define a type alias or associated type</li> <li>where denote clauses that constrain a type</li> </ul>"},{"location":"Computing/rust-keywords/#modules-and-others","title":"Modules and Others","text":"<ul> <li>as perform primitive casting, disambiguate the specific     trait containing an item, or rename items in use and     extern crate statements</li> <li>crate link an external crate or a macro variable     representing the crate in which the macro is defined</li> <li>extern link an external crate, function, or variable</li> <li>mod define a module</li> <li>use import symbols into scope</li> <li>unsafe denote unsafe code, functions, traits, or implementations</li> </ul>"},{"location":"Computing/rust-ownership/","title":"Rust Ownership","text":""},{"location":"Computing/rust-ownership/#operators","title":"Operators","text":"<pre><code>::          // name-space operator\nself        // Value (owner change)\n&amp;mut self   // Mutable reference (borrow)                               \n&amp;self       // Shared reference (only read)\n</code></pre>"},{"location":"Computing/rust-ownership/#ownership-rules","title":"Ownership rules","text":"<ol> <li>Each value in <code>Rust</code> has a variable that\u2019s called its owner.</li> <li>There can only be one owner at a time.</li> <li>When the owner goes out of scope, the value will be dropped.</li> </ol>"},{"location":"Computing/rust-ownership/#the-rules-of-references","title":"The Rules of References","text":"<ol> <li>At any given time, you can have either one mutable reference or any    number of immutable references.</li> <li>References must always be valid.</li> </ol>"},{"location":"Computing/rust-ownership/#lifetime-rules","title":"Lifetime rules","text":"<ol> <li>Each parameter that is a reference gets its own lifetime parameter.</li> <li>If there is exactly one input lifetime parameter, that lifetime is    assigned to all output lifetime parameters.</li> <li>If there are multiple input lifetime parameters, but one of them is     <code>&amp;self</code> or <code>&amp;mut self</code> the lifetime of self is assigned to all     output lifetime parameters.</li> </ol> <pre><code>let x: i32 = 10;\nlet y: i32 = x; // Copy\nlet s1: String = String::from(\"hello\");\nlet s2: String = s1; // Move (not shallow copy)\n//               s1.copy() // Fix the error, allocates in heap\nprintln!(\"{}, world!\", s1); // Error\n</code></pre>"},{"location":"Computing/rust-ownership/#lifetime","title":"Lifetime","text":"<p>Let people take pointers to random data on the stack, and the result is a pervasive unmanageable un-safety. It allows to holding a pointer to something that:</p> <ul> <li>went out of scope</li> <li>got mutated away</li> </ul> <p>A lifetime is the name of a region (~block/scope) of code somewhere in  a program.</p> <pre><code>// Only one reference in input, so the output must be derived\n// from that input\nfn foo(&amp;A) -&gt; &amp;B; // sugar for:\nfn foo&lt;'a&gt;(&amp;'a A) -&gt; &amp;'a B;\n// Many inputs, assume they're all independent\nfn foo(&amp;A, &amp;B, &amp;C); // sugar for:\nfn foo&lt;'a, 'b, 'c&gt;(&amp;'a A, &amp;'b B, &amp;'c C);\n// Methods, assume all output lifetimes are derived from `self`\nfn foo(&amp;self, &amp;B, &amp;C) -&gt; &amp;D; // sugar for:\nfn foo&lt;'a, 'b, 'c&gt;(&amp;'a self, &amp;'b B, &amp;'c C) -&gt; &amp;'a D;\n</code></pre> <p>In practical terms, <code>fn foo&lt;'a&gt;(&amp;'a A) -&gt; &amp;'a B</code> means that the input must live at least as long as the output. If you keep the output around for a long time, this will expand the region that the input must be valid for.</p>"},{"location":"Computing/rust-smartptr/","title":"Rust Smart Pointers","text":"<ul> <li><code>Box&lt;T&gt;</code> - a unique pointer to an object on the heap. Analogous to   C++\u2019s std::unique_ptr.</li> <li><code>Cow&lt;'a, B&gt;</code> - a clone-on-write smart pointer. Useful for when you   have a value that could be borrowed or owned.</li> <li><code>Rc&lt;T&gt;</code> - a shared pointer that provides shared ownership of a value   on a single thread. This smart pointer cannot be sent between threads   safely since it does not use atomic operations to maintain its   refcount (the compiler will make sure you don\u2019t accidentally do   this).</li> <li> <p><code>Arc&lt;T&gt;</code> - very similar to Rc except it uses atomic operations to   update its refcount, and thus is thread-safe. Similar to   std::shared_ptr.</p> </li> <li> <p><code>Pin</code></p> </li> <li> <p><code>MutexGuard</code></p> </li> <li> <p>Cell - A mutable memory location.</p> </li> <li>Ref - Wraps a borrowed reference to a value in a RefCell box. A   wrapper type for an immutably borrowed value from a RefCell. <li>RefCell - A mutable memory location with dynamically checked borrow   rules</li> <li>RefMut - A wrapper type for a mutably borrowed value from a   RefCell. <li> <p>UnsafeCell - The core primitive for interior mutability in Rust.</p> </li> <li> <p><code>Vec&lt;T&gt;/String/PathBuf/OsString</code> et al. - all of these are smart   pointers for owning dynamically allocated arrays of items on the   heap. Read their documentation for more specific details.</p> </li>"},{"location":"Computing/rust-stdlib/","title":"Rust Standard Library","text":""},{"location":"Computing/rust-stdlib/#core-primitive-types","title":"Core Primitive types","text":"<ul> <li>never: The <code>!</code> type, also called \u201cnever\u201d.</li> <li>core::array: A fixed-size array, denoted <code>[T; N]</code>, for the element type,   T, and the non-negative compile-time constant size, N.</li> <li>bool: The boolean type.</li> <li>core::char: A character type.</li> <li>core::f{32, 64}: A floating point type (specifically IEEE 754-2008).</li> <li>fn: Function pointers, like <code>fn(usize) -&gt; bool</code>.</li> <li>core::i{8, 16, 32, 64, 128, size}: The signed integer type.</li> <li>pointer: Raw, unsafe pointers, const T, and mut T.</li> <li>reference: References, &amp;T and &amp;mut T.</li> <li>core::slice: A dynamically-sized view into a contiguous sequence, <code>[T]</code>.   Contiguous here means that elements are laid out so that every element   is the same distance from its neighbors.</li> <li>core::str: String slices.</li> <li>tuple: A finite heterogeneous sequence, <code>(T, U, ..)</code>.</li> <li>core::u{8, 16, 32, 64, 128}: The unsigned integer type</li> <li>unit: The <code>()</code> type, also called \u201cunit\u201d.</li> <li>core::usize: The pointer-sized unsigned integer type.</li> </ul>"},{"location":"Computing/rust-stdlib/#common-types-and-collections","title":"Common types and Collections","text":"<ul> <li>array: Utilities for the array primitive type.</li> <li>core::ascii: Operations on <code>ASCII</code> strings and characters.</li> <li>char: Utilities for the char primitive type.</li> <li>collections: Collection types.</li> <li>fmt: Utilities for formatting and printing <code>Strings</code>.</li> <li>core::hash: Generic hashing support.</li> <li>core::iter: Composable external iteration.</li> <li>core::num: Additional functionality for numerics.</li> <li>core::ops: Overloadable operators.</li> <li>core::option: Optional values.</li> <li>primitive: This module reexports the primitive types to allow usage that     is not possibly shadowed by other declared types.</li> <li>core::result: Error handling with the Result type.</li> <li>slice: Utilities for the slice primitive type.</li> <li>str: Utilities for the str primitive type.</li> <li>string: A <code>UTF-8</code>\u2013encoded, growable string.</li> <li>vec: A contiguous growable array type with heap-allocated contents,     written <code>Vec&lt;T&gt;</code>.</li> </ul>"},{"location":"Computing/rust-stdlib/#smart-pointers-containers-and-memory","title":"Smart Pointers, Containers and Memory","text":"<ul> <li>core::alloc: Memory allocation APIs.</li> <li>core::any: Utilities for dynamic typing or type reflection.</li> <li>core::borrow: A module for working with borrowed data.</li> <li>boxed: The <code>Box&lt;T&gt;</code> type for heap allocation.</li> <li>core::clone: The <code>Clone</code> trait for types that cannot be \u2018implicitly copied\u2019.</li> <li>core::cell: Shareable mutable containers.</li> <li>core::mem: Basic functions for dealing with memory.</li> <li>core::pin: Types that pin data to its location in memory.</li> <li>core::ptr: Manually manage memory through raw pointers.</li> <li>rc: Single-threaded reference-counting pointers. <code>Rc</code> stands for     \u2018Reference Counted\u2019.</li> </ul>"},{"location":"Computing/rust-stdlib/#synchronous-asynchronous-and-concurrency","title":"Synchronous, Asynchronous and Concurrency","text":"<ul> <li>core::future: Asynchronous basic functionality.</li> <li>process: A module for working with processes.</li> <li>core::sync: Useful synchronization primitives.</li> <li>core::task: Types and Traits for working with asynchronous tasks.</li> <li>thread: Native threads.</li> </ul>"},{"location":"Computing/rust-stdlib/#types-and-traits","title":"Types and Traits","text":"<ul> <li>core::cmp: Utilities for comparing and ordering values.</li> <li>core::convert: Traits for conversions between types.</li> <li>core::default: The <code>Default</code> trait for types with a default value.</li> <li>core::marker: Primitive traits and types representing basic properties of     types.</li> </ul>"},{"location":"Computing/rust-stdlib/#io-os-and-network-features","title":"<code>IO</code>, <code>OS</code> and Network features","text":"<ul> <li>core::arch: <code>SIMD</code> and vendor intrinsics module.</li> <li>backtrace: Support for capturing a stack backtrace of an OS thread</li> <li>env: Inspection and manipulation of the process\u2019s environment.</li> <li>error: Interfaces for working with <code>Errors</code>.</li> <li>core::ffi: Utilities related to <code>FFI</code> bindings.</li> <li>fs: Filesystem manipulation operations.</li> <li>core::hint: Hints to compiler that affects how code should be emitted or     optimized. Hints may be compile time or runtime.</li> <li>io: Traits, helpers, and type definitions for core <code>I/O</code> functionality.</li> <li>net: Networking primitives for <code>TCP/UDP</code> communication.</li> <li>os: OS-specific functionality.</li> <li>core::panic: Panic support in the standard library.</li> <li>path: Cross-platform path manipulation.</li> <li>core::time: Temporal quantification.</li> </ul>"},{"location":"Computing/rust-tips/","title":"Rust Tips","text":"<ol> <li>Examples have first-class support in Cargo. Place them in a    directory <code>examples</code> next to <code>src</code>. They can then be run with    <code>cargo run --example foo</code>. They will need to import the crate in    order to use it.</li> <li>Prefer to use <code>module::function</code> instead of importing a free    function directly. This helps the developer track where they come    from. The only exception I make is for <code>min</code> and <code>max</code>.</li> <li>When <code>where</code> clauses are used, they go on a separate line from the    argument and return types, and the opening curly brace does as    well. When there are multiple clauses, each goes on a separate    line.</li> <li>Use trailing commas on arrays and structures. This reduces the    lines of <code>diff</code> when a new <code>struct</code> member is added.</li> <li>Evaluate comments for what consumers of a function need to know    versus what the implementor need to know. Use <code>Rustdoc</code> comments    (<code>///</code>) when talking to the consumer. It\u2019s reasonable to add    <code>Rustdoc</code> for non-public methods, so the consumer may be another    developer of the library.</li> <li>Remove useless documentation like \u201c\u2026 like <code>foo</code> but mutable\u201d.    Don\u2019t repeat information that is described in the function name or    type. Document information that cannot be captured that way.</li> <li>Note that <code>Rustdoc</code> uses <code>Markdown</code>; use <code>Markdwon</code> syntax to refer    to variables as <code>code</code>, for example.</li> <li>Instead of adding comments for each of the \u201cother\u201d cases, write    them out. Generally, annotating something in code is less brittle    that writing it in comments, as the complier checks the former and    not the latter.</li> <li>Instead of a debug assertion, add the explicit patterns it cannot    be and use something like <code>unimplemented!</code>.</li> <li>Prefer regular assertions instead of debug assertions in general;     there\u2019s no worse time for invalid data to occur than in     production. Only switch to debug assertions if profiling shows     that the assertion is adding significant overhead.</li> <li>Instead of dereferencing a value at every use in a loop,     pattern-match to <code>&amp;foo</code>, if the type is <code>Copy</code>.</li> <li>All code should have some tests, doubly so for data structures     that are intended to be used pervasively. The examples also     require a human to look at the output and decide if they are     correct.</li> <li>Check out the <code>|</code> and <code>@</code> aspects of pattern matching. These are     helpful to coalesce duplicate cases (like left/right symmetry) and     to avoid unwrapping and re-wrapping types like <code>Option</code>.</li> <li><code>Unbox</code> usually means to remove a value from a box and free the     box (<code>Box&lt;T&gt; -&gt; T</code>).</li> <li>Look into <code>QuickCheck</code>. Data structures have certain invariants     that should be upheld at all times, and generative testing helps     tease those out.</li> <li>I\u2019d go ahead and make a <code>Node::new</code> to avoid needing to set left     and right to <code>None</code> at the call site.</li> <li>I might prefer <code>while let Some(node) = self.current.as_ref()</code>     versus <code>while let Some(ref node) = *self.current</code>.</li> </ol>"},{"location":"Computing/rust-tips/#references","title":"References","text":"<ul> <li>Performance Book</li> <li>:simple-web: 100,000 Lines of Rust</li> <li>:simple-web: Come for the Foo, stay for the Bar</li> <li>:simple-web: Procedural macros workshop</li> </ul>"},{"location":"Computing/syscalls/","title":"SysCalls","text":""},{"location":"Computing/syscalls/#kinds-of-syscalls","title":"Kinds of SysCalls","text":"<ul> <li>File Management: are responsible for file manipulation such as creating a   file, reading a file, writing into a file etc.</li> <li>Information Maintenance: handle information and its transfer between the   operating system and the user program.</li> <li>Process Control: deal with processes such as process creation, process   termination etc.</li> <li>Device Management: are responsible for device manipulation such as reading   from device buffers, writing into device buffers etc.</li> <li>Signalling: are useful for interprocess communication. They also deal with   creating and deleting a communication connection.</li> </ul>"},{"location":"Computing/syscalls/#references","title":"REFERENCES","text":"<ul> <li>An Introduction to Linux System Calls</li> <li>Linux System Call Table for x86_64</li> <li>LINUX System Call Quick Reference</li> <li>Linux Inside: System Calls</li> </ul>"},{"location":"Humanities/gramatica_fantasia/","title":"Gram\u00e1tica de la Fantas\u00eda - Rodari","text":"<ul> <li>Juego de la china: Partiendo de una palabra, explorarla. Obtener cadenas de   palabras por cercan\u00eda f\u00f3nica. Indagar si tiene polisemia. Crear acr\u00f3sticos.   Una analog\u00eda verbal puede sucitar una met\u00e1fora.</li> <li>El prefijo arbitrario: Se modifica una palabra agregandole un prefijo   cualquiera.</li> <li>El error creativo: Aprovechar el error ortogr\u00e1fico como una creaci\u00f3n   aut\u00f3noma. Los ni\u00f1os suelen saltar de una palabra desconocida a una conocida   por familiaridad f\u00f3nica, y esto para asimilar una realidad desconocida.</li> <li>El binomio fant\u00e1stico: Aqu\u00ed las palabras no son tomadas en su significado   cotidiano, sino liberadas de las cadenas verbales de las que forman parte   cotidianamente. Enlazarlas con una preposici\u00f3n y los correspondientes   art\u00edculos. Crear contexto para dos sustantivos.</li> <li>La trama fant\u00e1stica: Se eligen al azar un sujeto y un predicado. Su uni\u00f3n   proporcionar\u00e1 la hip\u00f3tesis fant\u00e1stica sobre la cual trabajar. \u00bfQu\u00e9 pasar\u00eda   si\u2026</li> <li>La sintaxis fant\u00e1stica: Se elige una serie de preguntas al azar (\u00bfQui\u00e9n   era?, \u00bfd\u00f3nde estaba?, \u00bfqu\u00e9 hac\u00eda?, \u00bfqu\u00e9 dijo?, etc). El movimiento del   nonsense al sentido.</li> <li>Tratamiento de un verso: Elegir alg\u00fan verso y reescribirlo deform\u00e1ndolo, en   la b\u00fasqueda de un tema fant\u00e1stico. El ejercicio es para adiestrar a la   imaginaci\u00f3n de apartarse de los caminos demasiado comunes de significado.</li> <li>Falsa adivinanza: Es aquella que contiene ya de uno u otro modo su   respuesta.</li> <li>La doble ca\u00edda: Del rito a lo laico, de lo laico al juego (M\u00e1scara ritual,   traje teatral, marioneta).</li> <li>Decodificar el lado c\u00f3mico: Interpretar la historia, dando la resoluci\u00f3n   c\u00f3mica frente a la pat\u00e9tica.</li> <li> <p>An\u00e1lisis fant\u00e1stico: Sobre un personaje de cuento, consistir\u00e1 en   descmponerlo en sus factores primarios, con el fin de rastrear los elementos   para la construcci\u00f3n de nuevos binomios fant\u00e1sticos. Esto es, inventar   nuevas historias en torno al personaje. El personaje elegido puede ser   conocido (Pulgarcito), arquet\u00edpico (el vaquero, el brujo) o producto de un   binomio (el hombre de vidrio). Sus aventuras pueden deducirse de sus   caracter\u00edsticas.</p> </li> <li> <p>Construcci\u00f3n de un Limerick <code>-&gt;</code></p> <ol> <li>Elecci\u00f3n del protagonista</li> <li>Indicaci\u00f3n de una cualidad, expresada con una acci\u00f3n</li> <li>Realizaci\u00f3n del predicado en el 3\u00ba y 4\u00ba verso</li> <li>Elecci\u00f3n del ep\u00edteto final</li> <li>Rima <code>AABBA</code></li> </ol> </li> <li> <p>Construcci\u00f3n de una adivinanza <code>-&gt;</code></p> <ol> <li>Extra\u00f1amiento, definir al objeto como visto por primera vez</li> <li>Asociaci\u00f3n, de la definici\u00f3n crear aperturas a otros significados a partir de im\u00e1genes por analog\u00eda o comparaci\u00f3n</li> <li>Met\u00e1fora, crear una nueva definici\u00f3n metaf\u00f3rica</li> </ol> </li> <li> <p>Tratamiento de cuentos <code>-&gt;</code></p> <ul> <li>Binomio, usar al cuanto como el primer t\u00e9rmino del binomio y a una   palabra inesperada como el segundo</li> <li>\u00bfQu\u00e9 ocurre despu\u00e9s?, partiendo de las reglas internas del cuento y   mediante una nueva palabra, crear una continuaci\u00f3n</li> <li>Los cuentos al rev\u00e9s, invertir los valores de los personajes, trama</li> <li>Ensalada de cuentos, usar a un cuento como un t\u00e9rmino del binomio y a   otro como el otro</li> <li>Imitando cuentos, usar al cuento como un complejo sistema de coordenadas   fant\u00e1sticas.</li> <li>Transformaci\u00f3n de un tema, por reducci\u00f3n, amplificaci\u00f3n, sustituci\u00f3n e   intensificaci\u00f3n</li> </ul> </li> <li> <p>Principios de Propp <code>-&gt;</code></p> <ul> <li>Los elementos constantes son las funciones de los personajes</li> <li>El n\u00famero de funciones que incluye el cuento es limitado</li> <li>La sucesi\u00f3n de funciones es siempre id\u00e9ntica</li> <li>Funciones: alejamiento, prohibici\u00f3n, transgreci\u00f3n, interrogatorio,   informaci\u00f3n, enga\u00f1o, complicidad, fechor\u00eda, mediaci\u00f3n, principio de la   acci\u00f3n contraria, partida, primera funci\u00f3n del donante, reacci\u00f3n del   h\u00e9roe, recepci\u00f3n del objeto m\u00e1gico, desplazamiento, combate, marca,   victoria, reparaci\u00f3n, la vuelta, persecuci\u00f3n, socorro, llegada de   inc\u00f3gnito, pretensiones enga\u00f1osas, tarea dif\u00edcil, tarea cumplida,   reconocimiento, descubrimiento, transfiguraci\u00f3n, castigo, matrimonio.</li> </ul> </li> </ul>"},{"location":"Humanities/poesia_reglas/","title":"Formas de verso rimado","text":"<ul> <li>haiku: 5-7-5 (a veces <code>AXA</code>)</li> <li>tanka: 5-7-5-7-7 (en el verso 3\u00ba debe haber una imagen de enlace)</li> <li>limerick: <code>8a-8a-5b-5b-8a</code></li> <li>clerihew: <code>AABB</code></li> <li>copla: grupo de cuatro octos\u00edlabos, con rima asonante en los pares</li> <li>cuarteto: estrofa de cuatro versos en arte mayor, con rima consonante ABBA</li> </ul>"},{"location":"Humanities/tango_orchestras/","title":"Main tango orchestras by composer","text":""},{"location":"Humanities/tango_orchestras/#francisco-canaro-1888-1964","title":"Francisco Canaro (1888-1964)","text":""},{"location":"Humanities/tango_orchestras/#juan-darienzo-1900-1976","title":"Juan D\u2019Arienzo (1900-1976)","text":""},{"location":"Humanities/tango_orchestras/#carlos-di-sarli-1903-1960","title":"Carlos di Sarli (1903-1960)","text":""},{"location":"Humanities/tango_orchestras/#osvaldo-pugliese-1905-1995","title":"Osvaldo Pugliese (1905-1995)","text":""},{"location":"Humanities/tango_orchestras/#anibal-troilo-1914-1975","title":"Anibal Troilo (1914-1975)","text":""},{"location":"Humanities/tango_orchestras/#astor-piazzolla-1933-1990","title":"Astor Piazzolla (1933-1990)","text":""},{"location":"Mathematics/cat-basic_definitions/","title":"Definitions of Abstract Algebra","text":""},{"location":"Mathematics/cat-basic_definitions/#algebras","title":"Algebras","text":"<ul> <li>An algebra is defined by:<ol> <li>A set of values</li> <li>A set of operations</li> <li>A set of laws</li> </ol> </li> <li>A semigroup, monoid or group is a kind of algebra with     a defined binary operator \\(\\ast\\)</li> </ul> if \\(\\ast\\) Semigroup Monoid Group Abelian is closed T T T T is associative T T T T has identity F T T ? has inverse F F T ? is commutative ? ? ? T"},{"location":"Mathematics/cat-basic_definitions/#examples","title":"Examples","text":"<ul> <li>Z, Q, R and C are abelian groups under addition,     and abelian monoids under multiplication, because the     \\(0\\) doesn\u2019t have inverse.</li> <li>The set of all \\(2 x 2\\) matrices with real entries     form a monoid under multiplication (many singular matrices).</li> <li>The dihedral group:     \\(D_4 = \\{I, R, R^2, R^3, T_x, T_y , T_{1,3}, T_{2,4}\\}\\)</li> </ul>"},{"location":"Mathematics/cat-basic_definitions/#functor","title":"Functor","text":"<ul> <li>Functor is another kind of algebra</li> <li>A functor consists of:<ol> <li>A Container Type \\(f\\) that holds values of type \\(a\\)</li> <li>A function \\(fmap\\) that takes a function an lifts it</li> </ol> </li> <li>The Functor Laws<ol> <li>Identity      <code>fmap id == id</code></li> <li>Composition      <code>fmap (f.g) == (fmap f) . (fmap g)</code></li> <li>Structure preservation      <code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code></li> </ol> </li> </ul>"},{"location":"Mathematics/cat-basic_definitions/#applicative","title":"Applicative","text":"<ul> <li>The Applicative Laws:<ol> <li>Identity     <code>pure id &lt;*&gt; v == v</code></li> <li>Homomorphism     <code>pure f &lt;*&gt; pure x == pure (f x)</code></li> <li>Interchange     <code>u &lt;*&gt; pure y == pure ($ y) &lt;*&gt; u</code></li> <li>Composition     <code>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w == u &lt;*&gt; (v &lt;*&gt; w)</code></li> </ol> </li> <li>Applicatives are more composable than Monads.</li> </ul>"},{"location":"Mathematics/cat-basic_definitions/#monads","title":"Monads","text":"<ul> <li>The Monad Laws:<ol> <li>Left identity     <code>pure &lt;=&lt; f == f</code></li> <li>Right identity     <code>f &lt;=&lt; pure == f</code></li> <li>Associativity     <code>f &lt;=&lt; (g &lt;=&lt; x)== (f &lt;=&lt; g) &lt;=&lt; x</code></li> </ol> </li> <li>Every Monad is Applicative, and every Applicative is a     Functor, but said the opposite isn\u2019t always true.</li> <li>These are similar to the monoid laws, but generalized     for multiple types defined inside the monad. This sort     of structure is called a category in mathematics.</li> </ul>"},{"location":"Mathematics/cat-basic_definitions/#summarize","title":"Summarize","text":"<ul> <li>Functors are types for containers where we can <code>map</code>     pure functions on their contents.</li> <li>Applicative Functors are types where we can combine     \\(n\\) containers with a \\(n\\)-ary function.</li> <li>Monads are types <code>m</code> where we can sequentially compose     functions of the form <code>a -&gt; m</code>.</li> </ul>"},{"location":"Mathematics/cat-categories_haskell/","title":"Categories in Haskell","text":""},{"location":"Mathematics/cat-categories_haskell/#category-theory-as-a-theory-about-composition","title":"Category Theory as a theory about Composition","text":"<p>Some time ago the principles of structured programming revolutionized programming because they made blocks of code composable. Then came object oriented programming, which is all about composing objects. Functional programming is not only about composing functions and algebraic data structures; it makes concurrency composable, somethings that\u2019s virtually impossible in other programming languages.</p> <p>Functional programming is a subset of a more important overaching programming paradigm: compositional programming. Category Theory codifies this compositional style in a design pattern: the category. Unlike other design patterns, the category laws provides rigorous criteria for what does and does not qualify as compositional.</p>"},{"location":"Mathematics/cat-categories_haskell/#definitions","title":"Definitions","text":"<p>A Category is a two-sorted structure that encodes the algebra of composition. It has - objects - arrows - each pair of composable arrows has a composite arrow. - each object has an identity arrow for which the     composition operation is associative and unital.</p> <p>Isomorphism invariance principle: If \u2018A\u2019 and \u2018B\u2019 are isomorphic then every category theoretic property of \u2018A\u2019 is also true of \u2018B\u2019</p>"},{"location":"Mathematics/cat-categories_haskell/#examples-of-categories","title":"Examples of categories","text":"<ul> <li>The category Set: objects are (finite) sets and arrows     are functions.</li> <li>The syntactic category for some programming languages:     objects are types and arrows are programs.</li> </ul> <p>The categorical imperative \u201cprograms should form a category\u201d leads to the notion of monad.</p>"},{"location":"Mathematics/cat-categories_haskell/#category-laws","title":"Category Laws","text":"<p>Category theory says that for any given category there must be some sort of composition operator, say (\u00b7).</p> <p>Composition means we can omit arrows that can be deduced.</p> <ul> <li> <p>First Law: This composition operator is associative <pre><code>f \u00b7 (g \u00b7 h) = (f \u00b7 g) \u00b7 h\n</code></pre></p> </li> <li> <p>Second Law: This composition operator must have a left and     right identity <pre><code>I \u00b7 f = f\nf \u00b7 I = f\n</code></pre></p> </li> </ul>"},{"location":"Mathematics/cat-categories_haskell/#the-function-category-in-haskell","title":"The function category in Haskell","text":"<pre><code>id :: a -&gt; a\nid x = x\n(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)\nf . g = \\x -&gt; f (g x)\n{-- Associativity\n    (f . g) . h\n    == \\x -&gt; (f . g) . (h x)\n    == \\x -&gt; f (g (h x))\n    == \\x -&gt; f ((g . h) x)\n    == \\x -&gt; (f . (g . h)) x\n    == f . (g . h)\n-}\n</code></pre>"},{"location":"Mathematics/cat-categories_haskell/#the-kleisli-category-in-haskell","title":"The Kleisli category in Haskell","text":"<p>This is the category of monadic functions, which generalize ordinary functions. Mathematicians call this the \u201cKleisli\u201d category, and <code>Control.Monad</code> provides this two functions. Monadic functions just generalize ordinary functions and the Kleisli category demonstrates that monadic functions are composable, too.</p> <pre><code>return  :: Monad m =&gt; a -&gt; m a\n(&lt;=&lt;)   :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c)\n-- Compare both categories\nid     ::              (a -&gt;   a)\nreturn :: (Monad m) =&gt; (a -&gt; m a)\n(.)    ::              (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; (a -&gt;   c)\n(&lt;=&lt;)  :: (Monad m) =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c)\n(f  .  g) x = f     (g x)\n(f &lt;=&lt; g) x = f =&lt;&lt; (g x)\n</code></pre>"},{"location":"Mathematics/cat-categories_haskell/#from-kleisli-to-monad-laws","title":"From Kleisli to Monad Laws","text":"<pre><code>-- The Category Laws in Kelisli\nreturn &lt;=&lt; f    == f                -- Left  identity\nf &lt;=&lt; return    == f                -- Right identity\n(f &lt;=&lt; g) &lt;=&lt; h == f &lt;=&lt; (g &lt;=&lt; h)  -- Associativity\n-- Using (=&lt;&lt;) from the definition of (&lt;=&lt;)\nreturn =&lt;&lt; (f x)            == (f x)\nf =&lt;&lt; (return x)            == f x\n(\\y -&gt; f =&lt;&lt; (g y)) =&lt;&lt; h x == f =&lt;&lt; (g =&lt;&lt; (h x))\n-- Using (&gt;&gt;=) to flip the order of arguments\nm &gt;&gt;= return            == m\nreturn x &gt;&gt;= f          == f x\nm &gt;&gt;= (\\y -&gt; g y &gt;&gt;= f) == (m &gt;&gt;= g) &gt;&gt;= f\n</code></pre>"},{"location":"Mathematics/cat-categories_haskell/#references","title":"References","text":"<ul> <li>Peeling the banana: Recursion Schemes from first principles</li> <li>The Category design Pattern</li> </ul>"},{"location":"Mathematics/cat-functor/","title":"Functors and Applicatives","text":""},{"location":"Mathematics/cat-functor/#functors","title":"Functors","text":"<p>Uniform action over a parametrized type, generalizing the map function on lists. A functor transforms one category into another category. Functors arise every time we write compatibility layers and adapters between different pieces of software. In Haskell, the Functor class only encompass  the narrow case where the source and target categories are both categories of ordinary functions</p> <pre><code>class Functor f where\nfmap :: (a -&gt; b) -&gt; f a -&gt; f b\n(&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b\n-- map id       == id               identity\n-- map (f . g)  == map f . map g    composition\n</code></pre> <p>It is possible generalize the <code>fmap</code> function.</p> <pre><code>pure :: a -&gt; f a\n(&lt;*&gt;):: f (a -&gt; b) -&gt; f a -&gt; f b\nfmap0 :: a -&gt; f a\nfmap0 = pure\nfmap1 :: (a -&gt; b) -&gt; f a -&gt; f b\nfmap1 g x = pure g &lt;*&gt; x\nfmap2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; b c\nfmap2 g x y = pure g &lt;*&gt; x &lt;*&gt; y\n</code></pre>"},{"location":"Mathematics/cat-functor/#the-functor-laws-covariant-functor-laws","title":"The Functor Laws (covariant functor laws)","text":"<ul> <li>The identity law: must transform the identity in the source      category to the identity in the destination category.</li> <li>The compose law: must transform the composition operator in     the source category to the composition operator in the destination      category.</li> </ul>"},{"location":"Mathematics/cat-functor/#applicative","title":"Applicative","text":"<p>Map function in a context to the value in a context. The <code>&lt;*&gt;</code> operator generalize the <code>fmap</code> function. Can be chained together. All Applicative instances must also be Functor instances.</p> <pre><code>class (Functor f) =&gt; Applicative f where\npure :: a -&gt; f a\n(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b\n</code></pre> <p>When one uses a monad transformer it\u2019s possible appreciate that we are using a functor as an adapter layer between two categories: the base monad\u2019s Kleisli category and the transformed monad\u2019s Kleisli category.</p> <p>The functor design pattern embodies a philosophy of programming that emphasizes: - compatibility over standardization - specialization over monolithic frameworks - short-term completion over future-proofing</p>"},{"location":"Mathematics/cat-functor/#the-application-laws","title":"The Application Laws","text":"<pre><code>pure &lt;*&gt; id x   == x\npure (g x)      == pure g &lt;*&gt; pure x\nx &lt;*&gt; pure y    == pure (\\g -&gt; g y) &lt;*&gt; x\nx &lt;*&gt; y &lt;*&gt; z   == (pure (.) &lt;*&gt; x &lt;*&gt; y) &lt;*&gt; z\n-- Proof of 1st law\npure &lt;*&gt; id x\n(\\x -&gt; (\\y -&gt; x)) id &lt;*&gt; x  -- by def of pure\n(\\y -&gt; id) &lt;*&gt; x\n\\z -&gt; (\\y -&gt; id) z (x z)    -- by def of &lt;*&gt;\n\\z -&gt; id (x z)              -- using partial function application\n\\z -&gt; x z\n-- Prof of 2nd law\npure (g x)                  -- LEFT HAND SIDE\n\\y -&gt; g x                   -- by def of pure\npure g &lt;*&gt; pure x           -- RIGHT HAND SIDE\n\\y -&gt; g &lt;*&gt; \\z -&gt; x         -- by def of pure\n\\t -&gt; (\\y -&gt; g) t ((\\z -&gt; x) t) -- by def of &lt;*&gt;\n\\t -&gt; (\\y -&gt; g) t x\n\\t -&gt; g x\n-- Proof of 3rd law\nx &lt;*&gt; pure y                -- LEFT HAND SIDE\nx &lt;*&gt; \\z -&gt; y\n\\t -&gt; x t ((\\z -&gt; y) t)     -- by def of &lt;*&gt;\n\\t -&gt; x t y\npure (\\g -&gt; g y) &lt;*&gt; x      -- RIGHT HAND SIDE\n\\z -&gt; (\\g -&gt; g y) &lt;*&gt; x\n\\t -&gt; (\\z -&gt; (\\g -&gt; g y)) t (x t)-- by def of &lt;*&gt;\n\\t -&gt; (\\g -&gt; g y) (x t)\n\\t -&gt; x t y\n-- Proof of 4th law\nx &lt;*&gt; (y &lt;*&gt; z)             -- LEFT HAND SIDE\nx &lt;*&gt; (\\t -&gt; y t (z t))\n\\g -&gt; x g ((\\t-&gt; y t (z t)) g)\n\\g -&gt; x g (y g (z g))\n(pure (.) &lt;*&gt; x &lt;*&gt; y) &lt;*&gt; z-- RIGHT HAND SIDE\n((\\t -&gt; (.) (x t)) &lt;*&gt; y) &lt;*&gt; z\n(\\g -&gt; ((.) (x g)) (y g)) &lt;*&gt; z\n\\v -&gt; x v ((y v) (z v))\n</code></pre>"},{"location":"Mathematics/cat-higher_kinded_types/","title":"Higher-Kinded Types (HKT)","text":"<p>A higher kinded type is a concept that reifies a type constructor as an  actual type.</p> <p>A type constructor can be thought of in these analogies:</p> <ul> <li>like a function in the type universe</li> <li>as a type with a \u201chole\u201d in it</li> <li>as a container containing type(s)</li> <li>as a generic type, parameterised over other types</li> <li>as an endofunctor in the category of types</li> </ul> <p>To be able to use them in places where concrete \u201cproper\u201d types are usually  expected, a language must support the concept of higher kinded types.</p> <p>There are 3 keywords in \u201chigher kinded types\u201d:</p> <ul> <li> <p>Higher: The \u201chigher\u201d prefix is derived from the phrase \u201chigher order\u201d. In   terms of programming, it usually refers to a function that can at least take   other functions as input, or return functions as output. However I think in   this case, the prefix has become more general, and refers to a form of   recursive containment. Basically it\u2019s the idea that a type could contain   other types. See concepts like \u201chigher order messages\u201d. This makes sense, and   seems to define they very concept of type constructors and/or recursive data   structures. Here we use the word \u201ccontain\u201d to mean parameterisation of things   related to itself, and/or returning of things related to itself. Refer to 1st   order and 2nd order logic literature for more:</p> </li> <li> <p>Kinded: Kinds are the types of types. Most \u201cproper\u201d types have a kind   signature of <code>*</code>. But higher order types, or type constructors could have a   kind signature of <code>* -&gt; *</code>. The ability of having higher kinds defines a type   constructor.</p> </li> <li> <p>Types: Finally of course I believe this term signifies a reification of   our type constructors as a first class type that can be manipulated using the   same tools that we manipulate normal <code>*</code> \u201cproper\u201d types.</p> </li> </ul>"},{"location":"Mathematics/cat-higher_kinded_types/#haskell","title":"Haskell","text":"<p>Haskell has good support for higher kinded types. Every type constructor such as  they <code>[]</code> can be used as a \u201cfirst class type\u201d.</p> <p>This is specifically relevant to typeclasses such as the <code>Functor</code> typeclass.</p> <pre><code>&gt; :info Functor\nclass Functor (f :: * -&gt; *) where\nfmap :: (a -&gt; b) -&gt; f a -&gt; f b\n(GHC.Base.&lt;$) :: a -&gt; f b -&gt; f a\n-- Defined in \u2018GHC.Base\u2019\ninstance Functor Maybe -- Defined in \u2018Data.Maybe\u2019\ninstance Functor (Either a) -- Defined in \u2018Data.Either\u2019\ninstance Functor [] -- Defined in \u2018GHC.Base\u2019\ninstance Functor IO -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((-&gt;) r) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,) a) -- Defined in \u2018GHC.Base\u2019\n</code></pre> <p>Each of those instances are implementations of the Functor class for a  particular higher kinded type. For example, we see <code>[]</code>, which we know is a type  constructor but it is also a higher kinded type, since we can use it like a  \u201cfirst class type\u201d.</p>"},{"location":"Mathematics/cat-higher_kinded_types/#rust","title":"Rust","text":"<p>Rust 1.0 currently lacks support for higher kinded types. This doesn\u2019t mean it  doesn\u2019t have container types or type constructors. It certainly does. It just  hasn\u2019t reified them into a higher kinded type that can be used like a first  class citizen. It is however on the roadmap.</p> <p>Just a note about syntax:</p> <ul> <li><code>trait &lt;-&gt; class</code></li> <li><code>impl &lt;-&gt; instance</code></li> <li><code>enum/struct &lt;-&gt; data</code></li> </ul> <p>However there are interesting resources for working around this:</p> <ul> <li>Using a macro to get HKT!</li> <li>Using iterators instead!</li> </ul>"},{"location":"Mathematics/cat-higher_kinded_types/#other-readings","title":"Other readings","text":"<ul> <li>Lambda Cube</li> <li>2nd-order logic explained</li> <li>Examples of 3rd, 4th \u2026 logic sentences</li> <li>Who first coined the term Higher order Function</li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/","title":"Collected Lambda Calculus Functions","text":""},{"location":"Mathematics/cat-lambda_calculus/#collected-lambda-calculus-functions","title":"Collected Lambda Calculus Functions","text":"<p>The following is a small collection of functions in the untyped lambda calculus which I feel are noteworthy for one reason or another, either by relevance to the foundations of lambda calculus (such as the combinators and natural numbers) or by utility to people who wish to actively make use of this Turing tarpit. Some of them are taken from Wikipedia (which tends to be very reliable on mathematical issues), while others (primarily the list functions) I derived myself.</p> <p>Unless explicitly noted otherwise, natural numbers, booleans, pairs &amp; lists, and all functions for dealing with them use the Church encodings of their values. Operations on other types (e.g., negative or non-integral numbers) are not defined, and if the reader desires them, he must construct such types and the operations on them himself (possibly with the use of pairs acting as typed unions). Additionally, functions for operating on numbers, lists, etc. are only meant for use on those types; if a value of the wrong type is supplied (e.g., if a list is passed to [SUCC]{.L}) or a non-Church encoded value is used, the results are undefined.</p>"},{"location":"Mathematics/cat-lambda_calculus/#common-combinators","title":"Common Combinators","text":"<ul> <li>[K := \u03bbxy. x \u2261 X (X (X X)) \u2261 X\u2032 X\u2032 X\u2032]{.L}</li> <li>[S := \u03bbxyz. (x z) (y z) \u2261 X (X (X (X X))) \u2261 X K \u2261 X\u2032 (X\u2032 X\u2032) \u2261 B (B (B W) C) (B B)]{.L}</li> <li>[I := \u03bbx. x \u2261 S K S \u2261 S K K \u2261 X X]{.L}</li> <li>[X := \u03bbx. x S K]{.L} \u2014 also called [\u03b9]{.L} (iota)</li> <li>[X\u2032 := \u03bbx. x K S K]{.L}</li> <li>[B := \u03bbxyz. x (y z) \u2261 S (K S) K]{.L} \u2014 function composition</li> <li>[C := \u03bbxyz. x z y \u2261 S (S (K (S (K S) K)) S) (K K)]{.L}</li> <li>[W := \u03bbxy. x y y \u2261 S S (K (S K K))]{.L}</li> <li>[Y := \u03bbg. (\u03bbx. g (x x)) (\u03bbx. g (x x)) \u2261 S (K (S I I)) (S (S (K S) K) (K (S I I)))]{.L}</li> <li>[Y\u2032 := (\u03bbxy. x y x) (\u03bbyx. y (x y x)) \u2261 S S K (S (K (S S (S (S S K)))) K)]{.L}</li> <li>[\u0398 := (\u03bbxy. y (x x y)) (\u03bbxy. y (x x y))]{.L} \u2014 called the \"Turing fixed-point combinator\"</li> <li>[\u03c9 := \u03bbx. x x \u2261 S I I]{.L}</li> <li>[\u03a9 := \u03c9 \u03c9]{.L}</li> <li> <p>[\u03a92 := (\u03bbx. x x x) (\u03bbx. x x x)]{.L}</p> <p>A fixed point combinator is any function [F]{.L} for which [F g \u2261 g (F g)]{.L} for all [g]{.L}; examples include [Y]{.L}, [Y\u2032]{.L}, and [\u0398]{.L}. Since lambda calculus functions cannot refer to themselves by name, fixed point combinators are needed to implement recursion. For example, the factorial function can be implemented using [f := \u03bbgx. ISZERO x 1 (MULT x (g (PRED x)))]{.L}, which takes a function [g]{.L} and a number [x]{.L}; if [x]{.L} is not zero, it is multiplied by the result of [g (PRED x)]{.L}. Defining [FACTORIAL := Y\u00a0f]{.L} (or [Y\u2032\u00a0f]{.L} or [\u0398\u00a0f]{.L}) means that [FACTORIAL x \u2261 Y f x \u2261 f (Y f) x]{.L}, and so [f]{.L} is able to recurse on itself indefinitely.</p> </li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#natural-numbers","title":"Natural Numbers","text":"<ul> <li>[0 := \u03bbfx. x]{.L}</li> <li>[1 := \u03bbfx. f x]{.L}</li> <li>[2 := \u03bbfx. f (f x)]{.L}</li> <li>[3 := \u03bbfx. f (f (f x))]{.L}</li> <li>[4 := \u03bbfx. f (f (f (f x)))]{.L}</li> <li>[5 := \u03bbfx. f (f (f (f (f x))))]{.L}</li> <li>et cetera</li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#mathematical-operators","title":"Mathematical Operators","text":"<ul> <li> <p>The successor operator (given a natural number [n]{.math}, calculate     [n+1]{.math}):</p> <p>::: L SUCC := \u03bbnfx. f (n f x) ::: -   The predecessor operator (for all [n &gt; 0]{.math}, calculate [n-1]{.math}; for zero, return zero):</p> <p>PRED   :=   \u03bbnfx. n (\u03bbgh. h (g f)) (\u03bbu. x) (\u03bbu. u)          \u2261    \u03bbn. n (\u03bbgk. ISZERO (g 1) k (PLUS (g k) 1)) (\u03bbv. 0) 0          \u2261    \u03bbn. CAR (n (\u03bbx. PAIR (CDR x) (SUCC (CDR x))) (PAIR 0 0))</p> <ul> <li>Addition:</li> </ul> <p>PLUS   :=   \u03bbmnfx. n f (m f x)          \u2261    \u03bbmn. n SUCC m</p> <ul> <li>Subtraction \u2014 [SUB m n]{.L} evaluates to [m - n]{.math} if [m &gt; n]{.math} and to zero otherwise:</li> </ul> <p>::: L SUB := \u03bbmn. n PRED m ::: -   Multiplication:</p> <p>MULT   :=   \u03bbmnf. m (n f)          \u2261    \u03bbmn. m (PLUS n) 0          \u2261    B</p> <ul> <li>Division \u2014 [DIV a b]{.L} evaluates to a pair of two numbers, [a idiv b]{.math} and [a mod b]{.math}:</li> </ul> <p>::: L DIV := Y (\u03bbgqab. LT a b (PAIR q a) (g (SUCC q) (SUB a b) b)) 0 ::: -   Integer division:</p> <p>::: L IDIV := \u03bbab. CAR (DIV a b) ::: -   Modulus:</p> <p>::: L MOD := \u03bbab. CDR (DIV a b) ::: -   Exponentiation ([EXP a b \u2261 ab]{.L}):</p> <p>::: L EXP := \u03bbab. b a \u2261 C I ::: -   Factorial:</p> <p>FACTORIAL   :=   Y (\u03bbgx. ISZERO x 1 (MULT x (g (PRED x))))               \u2261    \u03bbn. Y (\u03bbgax. GT x n a (g (MUL a x) (SUCC x))) 1 1               \u2261    \u03bbn. n (\u03bbfax. f (MUL a x) (SUCC x)) K 1 1</p> <ul> <li>Fibonacci numbers \u2014 [FIBONACCI n]{.L} evaluates to the [n]{.L}-th Fibonacci number:</li> </ul> <p>::: L FIBONACCI := \u03bbn. n (\u03bbfab. f b (PLUS a b)) K 0 1 ::: -   Greatest common divisor/highest common factor:</p> <p>::: L GCD := (\u03bbgmn. LEQ m n (g n m) (g m n)) (Y (\u03bbgxy. ISZERO y x (g y (MOD x y)))) :::</p> </li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#booleans","title":"Booleans","text":"<p>Given a boolean value [b]{.L}, the expression [b t f]{.L} will evaluate to [t]{.L} if [b]{.L} is true and to [f]{.L} if [b]{.L} is false. This allows conditional expressions to be written simply as a condition applied directly to the two possible results without the need for an [IF]{.L} function.</p> <ul> <li>[TRUE := \u03bbxy. x \u2261 K]{.L}</li> <li>[FALSE := \u03bbxy. y \u2261 0 \u2261 \u03bbx. I \u2261 K I \u2261 S K \u2261 X (X X)]{.L}</li> <li>[AND := \u03bbpq. p q p]{.L}</li> <li>[OR := \u03bbpq. p p q]{.L}</li> <li>[XOR := \u03bbpq. p (NOT q) q]{.L}</li> <li>[NOT := \u03bbpab. p b a \u2261 \u03bbp. p FALSE TRUE]{.L}</li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#numeric-comparison-operators","title":"Numeric Comparison Operators","text":"<ul> <li> <p>Test whether a number is zero:</p> <p>::: L ISZERO := \u03bbn. n (\u03bbx. FALSE) TRUE ::: -   Less than:</p> <p>::: L LT := \u03bbab. NOT (LEQ b a) ::: -   Less than or equal to:</p> <p>::: L LEQ := \u03bbmn. ISZERO (SUB m n) ::: -   Equal to:</p> <p>::: L EQ := \u03bbmn. AND (LEQ m n) (LEQ n m) ::: -   Not equal to:</p> <p>::: L NEQ := \u03bbab. OR (NOT (LEQ a b)) (NOT (LEQ b a)) ::: -   Greater than or equal to:</p> <p>::: L GEQ := \u03bbab. LEQ b a ::: -   Greater than:</p> <p>::: L GT := \u03bbab. NOT (LEQ a b) :::</p> </li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#pairs-and-lists","title":"Pairs and Lists","text":"<p>Pairs and lists are structured the same way that they are in Lisp and its relatives: a pair is made up of two components, called the car and the cdr, and a list is either [NIL]{.L} (the empty list) or a pair whose cdr is another list (and whose car is an element of the enclosing list).</p> <ul> <li> <p>[PAIR x y]{.L} \u2014 create a pair with a car of [x]{.L} and a cdr of     [y]{.L}; also called [CONS]{.L}:</p> <p>::: L PAIR := \u03bbxyf. f x y ::: -   [CAR p]{.L} \u2014 get the car of pair [p]{.L}; also called [FIRST]{.L} or [HEAD]{.L}:</p> <p>::: L CAR := \u03bbp. p TRUE ::: -   [CDR p]{.L} \u2014 get the cdr of pair [p]{.L}; also called [SECOND]{.L}, [TAIL]{.L}, or [REST]{.L}:</p> <p>::: L CDR := \u03bbp. p FALSE ::: -   The empty list:</p> <p>::: L NIL := \u03bbx. TRUE ::: -   [NULL p]{.L} \u2014 evaluates to [TRUE]{.L} if [p]{.L} is [NIL]{.L} or to [FALSE]{.L} if [p]{.L} is a normal pair (all other types are undefined):</p> <p>::: L NULL := \u03bbp. p (\u03bbxy. FALSE) :::</p> </li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#list-functions","title":"List Functions","text":"<ul> <li> <p>Concatenate two lists:</p> <p>::: L APPEND := Y (\u03bbgab. NULL a b (PAIR (CAR a) (g (CDR a) b))) ::: -   Calculate the length of a list:</p> <p>::: L LENGTH := Y (\u03bbgcx. NULL x c (g (SUCC c) (CDR x))) 0 ::: -   [INDEX x i]{.L} \u2014 evaluates to the [i]{.L}-th (zero-based) element of list [x]{.L}, assuming that [x]{.L} has at least [i+1]{.math} elements:</p> <p>::: L INDEX := \u03bbxi. CAR (i CDR x) ::: -   Get the last element in a list:</p> <p>::: L LAST := Y (\u03bbgx. NULL x NIL (NULL (CDR x) (CAR x) (g (CDR x)))) ::: -   Get a list without its last element:</p> <p>::: L TRUNCATE := Y (\u03bbgx. NULL x NIL (NULL (CDR x) NIL (PAIR (CAR x) (g (CDR x))))) ::: -   Reverse a list:</p> <p>::: L REVERSE := Y (\u03bbgal. NULL l a (g (PAIR (CAR l) a) (CDR l))) NIL ::: -   [RANGE s e]{.L} \u2014 evaluates to a list of all natural numbers from [s]{.L} up through [e]{.L}, or to [NIL]{.L} when [s\u00a0&gt;\u00a0e]{.math}.</p> <p>::: L RANGE := \u03bbse. Y (\u03bbgc. LEQ c e (PAIR c (g (SUCC c) e)) NIL) s ::: -   [LIST n a0 a1 ... an-1]{.L} \u2014 evaluates to [a0 ... an-1]{.L} as a list</p> <p>::: L LIST := \u03bbn. n (\u03bbfax. f (PAIR x a)) REVERSE NIL ::: -   [APPLY f x]{.L} \u2014 passes the elements of the list [x]{.L} to [f]{.L}:</p> <p>::: L APPLY := Y (\u03bbgfx. NULL x f (g (f (CAR x)) (CDR x))) ::: -   [MAP f x]{.L} \u2014 maps each element of the list [x]{.L} through [f]{.L}:</p> <p>::: L MAP := Y (\u03bbgfx. NULL x NIL (PAIR (f (CAR x)) (g f (CDR x)))) ::: -   [FILTER f x]{.L} \u2014 evaluates to a list of all [e]{.L} in the list [x]{.L} for which [f e]{.L} is [TRUE]{.L} (assuming that [f]{.L} returns only [TRUE]{.L} or [FALSE]{.L} for all elements of [x]{.L}):</p> <p>::: L FILTER := Y (\u03bbgfx. NULL x NIL (f (CAR x) (PAIR (CAR x)) I (g f (CDR x)))) ::: -   [CROSS f l m]{.L} \u2014 evaluates to a list of all values of [f a b]{.L} where [a]{.L} is in the list [l]{.L} and [b]{.L} is in the list [m]{.L}. To obtain the Cartesian cross product of [l]{.L} and [m]{.L}, supply [PAIR]{.L} (or a similar function) for [f]{.L}.</p> <p>::: L CROSS := \u03bbflm. FOLD-LEFT APPEND NIL (MAP (\u03bbx. MAP (f x) m) l) ::: -   [FOLD-LEFT f e x]{.L} \u2014 Apply [f a]{.L} to each element of the list [x]{.L}, where [a]{.L} is the result of the previous application (or [e]{.L} for the first application) and return the result of the last application:</p> <p>::: L FOLD-LEFT := Y (\u03bbgfex. NULL x e (g f (f e (CAR x)) (CDR x))) ::: -   [FOLD-RIGHT f e x]{.L} \u2014 Apply [(\u03bby. f y a)]{.L} to each element of the list [x]{.L} in reverse order, where [a]{.L} is the result of the previous application (or [e]{.L} for the first application) and return the result of the last application:</p> <p>::: L FOLD-RIGHT := \u03bbfex. Y (\u03bbgy. NULL y e (f (CAR y) (g (CDR y)))) x :::</p> </li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#other","title":"Other","text":"<ul> <li> <p>[GET n i a0 a1 ... an-1 =\u03b2 ai]{.L}:</p> <p>::: L GET := \u03bbni. i K (SUB n (SUCC i) K) :::</p> </li> </ul>"},{"location":"Mathematics/cat-lambda_calculus/#sources","title":"Sources","text":"<ul> <li>Wikipedia: Lambda     calculus</li> <li>Wikipedia: Combinatory     logic</li> <li>Wikipedia: SKI combinator     calculus</li> <li>Wikipedia: Fixed point     combinator</li> <li>Wikipedia: B,C,K,W     system</li> </ul> <p>Main Page</p> <p>$Id: lambda.html,v 1.3 2014/06/23 01:42:31 jwodder Exp jwodder $ :::</p>"},{"location":"Mathematics/cat-monad/","title":"Monads introduction","text":""},{"location":"Mathematics/cat-monad/#definition","title":"Definition","text":"<p>A monad is an algebraic structure in category theory. In Haskell it is  used to describe computations as sequences of steps, and to handle side effects such as state and IO. When dealing with values with context,  Monad type-class helps us by automatically handling the context for us.</p> <p>A monad consists of three objects, which must satisfy the monad laws.</p>"},{"location":"Mathematics/cat-monad/#whats-the-point-of-monads","title":"What\u2019s the point of monads?","text":"<ol> <li>Supports pure programming with effects.</li> <li>Use of monads is explicit in types.</li> <li>Can generalise functions to any effect.</li> </ol> Type Effect <code>a -&gt; Maybe b</code> Exceptions <code>a -&gt; List b</code> Non-determinism <code>a -&gt; ST b</code> Internal state <code>a -&gt; IO b</code> Input/Output <code>((a -&gt; r) -&gt; r) -&gt; Cont r a</code> Promises"},{"location":"Mathematics/cat-monad/#the-three-basic-objects","title":"The three basic objects","text":"<ul> <li>A type constructor M, such that for any type a, the type      M a is the type of a computation in the monad M that      produces a result of type a.</li> <li>The bind operator (<code>&gt;&gt;=</code>). A function that takes two computations     and performs them one after the other, making the result of the     first computation available to the second.</li> <li>The return function <code>return</code>. A function such that if x::a,     then return x is a computation in M that, when executed     will produce a value of type a.</li> </ul>"},{"location":"Mathematics/cat-monad/#the-monad-type-class","title":"The Monad type class","text":"<pre><code>class Monad m where\nreturn  :: a -&gt; m a\n(&gt;&gt;=)   :: m a -&gt; (a -&gt; m b) -&gt; m b -- bind\n(&gt;&gt;)    :: m a -&gt; m b -&gt; m b        -- then\n-- m &gt;&gt; n = m &gt;&gt;= _ -&gt; n\nfail    :: String -&gt; m a\n</code></pre>"},{"location":"Mathematics/cat-monad/#the-monad-laws","title":"The Monad Laws","text":"<ul> <li>The right unit law: <code>m &gt;&gt;= return</code> equates to <code>m</code></li> <li>The left unit law: <code>return x &gt;&gt;= f</code> equates to <code>f x</code></li> <li>The associativity law: <code>(m &gt;&gt;= f) &gt;&gt;= g</code> equates to      <code>m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g)</code></li> </ul>"},{"location":"Mathematics/cat-monad/#the-functor-laws-covariant-functor-laws","title":"The Functor Laws (covariant functor laws)","text":"<ul> <li>The identity law: must transform the identity in the source      category to the identity in the destination category.</li> <li>The compose law: must transform the composition operator in     the source category to the composition operator in the destination      category.</li> </ul>"},{"location":"Mathematics/cat-monad/#the-applicative-laws-for-functions","title":"The Applicative Laws for functions","text":""},{"location":"Mathematics/cat-monad/#syntax-rules-for-do","title":"Syntax rules for <code>do</code>","text":"<pre><code>do { x }            --&gt; x\ndo { x; &lt;xs&gt; }      --&gt; x &gt;&gt; do { &lt;xs&gt; }\ndo { a &lt;- x; &lt;xs&gt; } --&gt; x &gt;&gt;= a -&gt; do { &lt;xs&gt; }\ndo { let &lt;declarations&gt;; xs }\n--&gt; let &lt;declarations&gt; in do { xs }\n</code></pre>"},{"location":"Mathematics/cat-monad/#implementation-of-return-bind-and-then","title":"Implementation of <code>return</code>, <code>bind</code> and <code>then</code>","text":"<pre><code>return  :: (Monad m) =&gt; a   -&gt; m a\nreturn x = State $ \\s -&gt; (x, s)\n(&gt;&gt;=)   :: (Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b\nm &gt;&gt;= k  = State $ \\s -&gt; let (a, s') = runState m s\nin runState (k a) s'\n</code></pre>"},{"location":"Mathematics/cat-monad/#functors-and-application","title":"Functors and Application","text":"<p>Functors: Uniform action over a parametrized type, generalizing the map function on lists. A functor transforms one category into another category. Functors arise every time we write compatibility layers and adapters between different pieces of software. In Haskell, the Functor class only encompass  the narrow case where the source and target categories are both categories of ordinary functions</p> <pre><code>class Functor f where\nfmap :: (a -&gt; b) -&gt; f a -&gt; f b\n(&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b\n-- map id       == id               identity\n-- map (f . g)  == map f . map g    composition\n</code></pre> <p>Applicative: Map function in a context to the value in a context. Can be chained together. All Applicative instances must also be Functor instances.</p> <pre><code>class (Functor f) =&gt; Applicative f where\npure :: a -&gt; f a\n(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b\n</code></pre> <p>When one uses a monad transformer it\u2019s possible appreciate that we are using a functor as an adapter layer between two categories: the base monad\u2019s Kleisli category and the transformed monad\u2019s Kleisli category.</p> <p>The functor design pattern embodies a philosophy of programming that emphasizes: - compatibility over standardization - specialization over monolithic frameworks - short-term completion over future-proofing</p>"},{"location":"Mathematics/cat-notes/","title":"Memoization (in terms of set theory)","text":"<ul> <li>A relation is just a subset of pairs</li> <li>These set relations forms a cartesian product</li> <li>So by definition, any subset of the cartesian product is a relation</li> <li>Relations do not have directionality, but functions do</li> <li>A function can therefore be said to be a relation with directional   constraints, namely those going from a domain (lhs) to a codomain (rhs) The   following structure holds for invertible functions</li> </ul> <pre><code>f :: a -&gt; b\ng :: b -&gt; a\ng after f = id\nf after g = id\n</code></pre> <p>This geometric understanding helps intuit a meaning for isomorphisms (and this is for isomorphisms in any given category.)</p>"},{"location":"Science/bio-basic_fungi/","title":"Bio basic fungi","text":"<p>La herbolaria no es una farmacologia sin metodo, es una practica.</p> <p>Hongos - patogenos y parasitarios - comestibles - psicoactivos - entomopatogenos (bioinsecticidas) - liquenes (asociacion hongos, algas y bacterias)     indicadores de la calidad de aire - miscelio (biomateriales) - levaduras (edicion genetica y escalamiento industrial, eucariotas)</p>"}]}